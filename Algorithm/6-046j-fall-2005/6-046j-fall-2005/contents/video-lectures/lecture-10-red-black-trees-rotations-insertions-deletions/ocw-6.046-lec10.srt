1
00:00:07 --> 00:00:10
Good morning.
It looks like 9:30 is getting

2
00:00:10 --> 00:00:13
earlier and earlier for
everyone.

3
00:00:13 --> 00:00:17
Hello to all the people
watching at home.

4
00:00:17 --> 00:00:22
I think there should be a
requirement that if you're

5
00:00:22 --> 00:00:26
watching the video,
you can only watch it

6
00:00:26 --> 00:00:31
9:30-11:00 on Sunday,
or at least start watching then

7
00:00:31 --> 00:00:36
just so you can all feel our
mornings.

8
00:00:36 --> 00:00:40
Today, we're going to talk
about balanced search trees.

9
00:00:40 --> 00:00:42
Now, we've hinted at this for a
while.

10
00:00:42 --> 00:00:46
Our goal today is to get a
search tree data structure,

11
00:00:46 --> 00:00:50
so we can insert,
delete, and search all at log n

12
00:00:50 --> 00:00:53
time for operations.
So, we want a tree that's

13
00:00:53 --> 00:00:56
guaranteed to be log n in
height.

14
00:00:56 --> 00:01:01
So, that's a balanced search
tree data structure.

15
00:01:01 --> 00:01:13


16
00:01:13 --> 00:01:18
And, we want a data structure
that can maintain a dynamic set

17
00:01:18 --> 00:01:22
of n elements in log n time for
operation.

18
00:01:22 --> 00:01:32


19
00:01:32 --> 00:01:35
So, we'll say,
using a tree of height order

20
00:01:35 --> 00:01:38
log n.
Now, if you look very closely,

21
00:01:38 --> 00:01:42
we haven't actually defined
what a search tree data

22
00:01:42 --> 00:01:45
structure is.
We've defined what a binary

23
00:01:45 --> 00:01:50
search tree data structure is,
and that's one particular kind.

24
00:01:50 --> 00:01:54
And that's what we will be
focusing on today.

25
00:01:54 --> 00:01:57
In recitation on Friday,
we will look at,

26
00:01:57 --> 00:02:01
or you will like that,
balanced search trees that are

27
00:02:01 --> 00:02:07
not necessarily binary.
Each node can have a constant

28
00:02:07 --> 00:02:09
number of children,
not just two.

29
00:02:09 --> 00:02:13
So, I'm defining is generally.
You actually see what a search

30
00:02:13 --> 00:02:15
tree is in the general case
later on.

31
00:02:15 --> 00:02:19
Today, we will just be focusing
on the binary case.

32
00:02:19 --> 00:02:22
So, I won't define this yet.
So, there are a lot of

33
00:02:22 --> 00:02:26
different balanced search tree
data structures.

34
00:02:26 --> 00:02:30
So, these are the main ones
that I know of.

35
00:02:30 --> 00:02:35
The first one was AVL trees.
This was invented in 1962.

36
00:02:35 --> 00:02:41
So, that was the beginning of
fast data structures.

37
00:02:41 --> 00:02:47
The next three sort of come
together and this is what you

38
00:02:47 --> 00:02:51
will cover in recitation this
week.

39
00:02:51 --> 00:02:56
So, these are non binary trees.
Instead of binary,

40
00:02:56 --> 00:03:02
we have maybe binary and
tertiary, or maybe binary and

41
00:03:02 --> 00:03:08
tertiary, or quaternary,
over a general concept degree,

42
00:03:08 --> 00:03:13
B.
So, that's another way you can

43
00:03:13 --> 00:03:16
get balance.
Two-three trees,

44
00:03:16 --> 00:03:22
which were the second trees to
be invented, they were invented

45
00:03:22 --> 00:03:27
in 1970 by Hopcroft.
The trees we will cover today

46
00:03:27 --> 00:03:33
are called red black trees.
These are binary search trees

47
00:03:33 --> 00:03:38
of guaranteed logarithmic
height.

48
00:03:38 --> 00:03:44
So then, there's some others.
So, skip lists are ones that we

49
00:03:44 --> 00:03:49
will cover next week.
It's not exactly a tree,

50
00:03:49 --> 00:03:55
but it's more or less a tree,
and one that you will see in

51
00:03:55 --> 00:04:02
your problem set this week are
treeps, which I won't talk too

52
00:04:02 --> 00:04:06
much about here.
But they are in some sense

53
00:04:06 --> 00:04:09
easier to get because they
essentially just rely on the

54
00:04:09 --> 00:04:13
material from last Monday.
So, on Monday we saw that if we

55
00:04:13 --> 00:04:16
just randomly built a binary
search tree, it's going to have

56
00:04:16 --> 00:04:19
log n height most of the time in
expectation.

57
00:04:19 --> 00:04:22
So, treeps are a way to make
that dynamic,

58
00:04:22 --> 00:04:25
so that instead of just having
a static set of n items,

59
00:04:25 --> 00:04:28
you can insert and delete into
those items and still

60
00:04:28 --> 00:04:33
effectively randomly permute
them and put them in a tree.

61
00:04:33 --> 00:04:35
So in some sense,
it's the easiest.

62
00:04:35 --> 00:04:39
It's also one of the most
recent search tree data

63
00:04:39 --> 00:04:42
structures.
That was invented in 1996 by a

64
00:04:42 --> 00:04:45
couple of geometers,
Rimon Sidell and Aragen.

65
00:04:45 --> 00:04:49
So, those are just some search
tree data structures.

66
00:04:49 --> 00:04:53
The only ones we will not cover
in this class are AVL trees.

67
00:04:53 --> 00:04:57
They're not too hard.
If you're interested,

68
00:04:57 --> 00:05:00
you should read about them
because they're fun.

69
00:05:00 --> 00:05:05
I think they are a problem in
the textbook.

70
00:05:05 --> 00:05:10
OK, but today,
we're going to focus on red

71
00:05:10 --> 00:05:17
black trees, which is a fairly
simple idea, red black trees.

72
00:05:17 --> 00:05:24
And, it's a particular way of
guaranteeing this logarithmic

73
00:05:24 --> 00:05:30
height so that all the
operations can be supported in

74
00:05:30 --> 00:05:36
log n time.
So, they are binary search

75
00:05:36 --> 00:05:40
trees.
And, they have a little bit of

76
00:05:40 --> 00:05:47
extra information in each node
called the color field.

77
00:05:47 --> 00:06:02


78
00:06:02 --> 00:06:06
And there are several
properties that a tree with a

79
00:06:06 --> 00:06:11
color field has to satisfy in
order to be called a red black

80
00:06:11 --> 00:06:14
tree.
These are called the red black

81
00:06:14 --> 00:06:17
properties.
And, this will take a little

82
00:06:17 --> 00:06:21
bit of time to write down,
but it's all pretty simple.

83
00:06:21 --> 00:06:26
So once I write them down I
will just say what they really

84
00:06:26 --> 00:06:30
mean.
There's four properties.

85
00:06:30 --> 00:06:34
The first one's pretty simple.
Every node is either red or

86
00:06:34 --> 00:06:37
black, hence the name of red
black trees.

87
00:06:37 --> 00:06:42
So, the color field is just a
single bit specifying red or

88
00:06:42 --> 00:06:43
black.
And red nodes,

89
00:06:43 --> 00:06:48
I'm going to denote by a double
circle because I don't have

90
00:06:48 --> 00:06:51
colored chalk here,
and black nodes will be a

91
00:06:51 --> 00:06:54
single circle.
And you probably don't have

92
00:06:54 --> 00:07:00
colored pens either,
so it will save us some grief.

93
00:07:00 --> 00:07:04
Red is double circle;
black is single circle.

94
00:07:04 --> 00:07:09
And, we sort of prefer black
nodes in some sense.

95
00:07:09 --> 00:07:13
Red nodes are a pain,
as we'll see.

96
00:07:13 --> 00:07:19
OK, second property is that the
root and the leaves are all

97
00:07:19 --> 00:07:22
black.
And, I'm going to pull a little

98
00:07:22 --> 00:07:26
trick here.
Treat binary search trees a

99
00:07:26 --> 00:07:33
little bit differently than we
have in the past.

100
00:07:33 --> 00:07:36
Normally, you think of the tree
as a bunch of nodes.

101
00:07:36 --> 00:07:39
Each node could have zero or
one or two children,

102
00:07:39 --> 00:07:43
something like this.
I'm going to imagine appending

103
00:07:43 --> 00:07:46
every place where a node does
not have a child.

104
00:07:46 --> 00:07:50
I'm going to put a little dot
here, an external node,

105
00:07:50 --> 00:07:53
which I call a leaf.
So, normally leaves would have

106
00:07:53 --> 00:07:57
been these items.
I'm just going to add to every

107
00:07:57 --> 00:08:02
absent child pointer a leaf.
And, these will be my leaves.

108
00:08:02 --> 00:08:07
These are really the nil
pointers from each of these

109
00:08:07 --> 00:08:11
nodes.
So now, every internal node has

110
00:08:11 --> 00:08:15
exactly two children,
and every leaf has zero

111
00:08:15 --> 00:08:19
children.
OK, so these are those I'm

112
00:08:19 --> 00:08:22
referring to.
These are black,

113
00:08:22 --> 00:08:26
and this guy is black according
to rule two.

114
00:08:26 --> 00:08:31
Now the properties get a little
bit more interesting.

115
00:08:31 --> 00:08:37
The parent of every red node is
black.

116
00:08:37 --> 00:08:42
So, whenever I have a red node,
its parent has to be black,

117
00:08:42 --> 00:08:45
a single circle.
OK, so in other words,

118
00:08:45 --> 00:08:50
if you look at a path in the
tree you can never have two red

119
00:08:50 --> 00:08:53
nodes consecutive.
You can have,

120
00:08:53 --> 00:08:55
at most, red,
black, red, black.

121
00:08:55 --> 00:08:59
You can have several black
nodes consecutive,

122
00:08:59 --> 00:09:06
but never two red nodes.
OK, and then one more rule.

123
00:09:06 --> 00:09:13
It says a little bit more about
such paths.

124
00:09:13 --> 00:09:21
So, if we take a simple path,
meaning it doesn't repeat any

125
00:09:21 --> 00:09:28
vertices from a node,
x, to a descended leaf of x,

126
00:09:28 --> 00:09:36
all such paths to all
descendant leaves have the same

127
00:09:36 --> 00:09:42
number of black nodes on them.

128
00:09:42 --> 00:09:59


129
00:09:59 --> 00:10:02
So, let me draw a picture.
We have some tree.

130
00:10:02 --> 00:10:05
We have some node,
x, in the tree.

131
00:10:05 --> 00:10:09
And, I'm looking at all the
paths from x down to some

132
00:10:09 --> 00:10:14
descendant leaf down here at the
bottom of the tree.

133
00:10:14 --> 00:10:19
All of these paths should have
the same number of black nodes.

134
00:10:19 --> 00:10:23
So, here I'll draw that each
one has four black nodes,

135
00:10:23 --> 00:10:28
the leaf, and three above it.
We know that from property

136
00:10:28 --> 00:10:31
three, at most,
half of the nodes are red

137
00:10:31 --> 00:10:38
because whenever I have a red
node, the parent must be black.

138
00:10:38 --> 00:10:44
But I want all of these paths
to have exactly the same number

139
00:10:44 --> 00:10:48
of black nodes.
One subtlety here is that the

140
00:10:48 --> 00:10:52
black height,
I didn't really leave room.

141
00:10:52 --> 00:10:58
So I'll write it over here.
This should be the same for all

142
00:10:58 --> 00:11:04
paths, but in particular,
the count I'm interested in

143
00:11:04 --> 00:11:09
does not include x itself.
OK, so if x is black,

144
00:11:09 --> 00:11:12
I'm only calling the black
height.

145
00:11:12 --> 00:11:15
So, the black height of x is
this count four.

146
00:11:15 --> 00:11:19
And even if x is black,
the black height is four.

147
00:11:19 --> 00:11:23
So, these are just some minor
details to get all of the

148
00:11:23 --> 00:11:27
algorithms a bit clean.
So, let's look at an example of

149
00:11:27 --> 00:11:31
a red black tree.
So, yeah, I'll show you an

150
00:11:31 --> 00:11:34
example.
Then I'll say why we care about

151
00:11:34 --> 00:11:36
these properties.

152
00:11:36 --> 00:12:16


153
00:12:16 --> 00:12:18
OK, so this tree has several
properties.

154
00:12:18 --> 00:12:21
The first thing is that it's a
binary search tree.

155
00:12:21 --> 00:12:24
OK, and so you can check an [in
order traversal?].

156
00:12:24 --> 00:12:26
It should give these numbers in
sorted order:

157
00:12:26 --> 00:12:28
three, seven,
eight, ten, 11,

158
00:12:28 --> 00:12:30
18, 22, 26.
So, it's a valid binary search

159
00:12:30 --> 00:12:33
tree.
We've appended these leaves

160
00:12:33 --> 00:12:36
with no keys in them.
They are just hanging around.

161
00:12:36 --> 00:12:39
Those are the nil pointers.
So, each of these,

162
00:12:39 --> 00:12:43
you can call them nil.
They are all just marked there,

163
00:12:43 --> 00:12:47
wherever there is absent child.
And then, I've double circled

164
00:12:47 --> 00:12:49
some of the nodes to color them
red.

165
00:12:49 --> 00:12:52
OK, if I didn't,
the black heights wouldn't

166
00:12:52 --> 00:12:54
match up.
So, I have to be a little bit

167
00:12:54 --> 00:12:56
careful.
From every node,

168
00:12:56 --> 00:12:59
we'd like to measure the number
of black nodes from that node

169
00:12:59 --> 00:13:02
down to any descendent leaf.
So, for example,

170
00:13:02 --> 00:13:07
the nil pointers,
their black height is zero.

171
00:13:07 --> 00:13:09
Good.
That's always the answer.

172
00:13:09 --> 00:13:12
So, these guys always have
black height zero.

173
00:13:12 --> 00:13:17
I'll just represent that here.
Black height equals zero.

174
00:13:17 --> 00:13:19
OK, what's the black height of
three?

175
00:13:19 --> 00:13:22
Zero?
Not quite, because these nodes

176
00:13:22 --> 00:13:25
are black.
So the black height is one.

177
00:13:25 --> 00:13:29
You're right that we don't
count three even though it's

178
00:13:29 --> 00:13:34
black.
It's not included in the count.

179
00:13:34 --> 00:13:38
But the leaves count.
And there's only two paths

180
00:13:38 --> 00:13:43
here, and they each have the
same number of black nodes as

181
00:13:43 --> 00:13:46
they should.
Over here, let's say eight also

182
00:13:46 --> 00:13:50
has black height one even though
it's red.

183
00:13:50 --> 00:13:53
OK: same with 11,
same with 26.

184
00:13:53 --> 00:13:55
Each of them only has two
paths.

185
00:13:55 --> 00:14:00
Each path has one black node on
it.

186
00:14:00 --> 00:14:02
Ten: what's the black height?
It's still one,

187
00:14:02 --> 00:14:05
good, because we don't count
ten.

188
00:14:05 --> 00:14:07
There's now four paths to
leaves.

189
00:14:07 --> 00:14:10
Each of them contains exactly
one black node,

190
00:14:10 --> 00:14:12
plus the root,
which we don't count.

191
00:14:12 --> 00:14:14
22: same thing,
hopefully.

192
00:14:14 --> 00:14:17
This is getting a little more
interesting.

193
00:14:17 --> 00:14:20
There's one path here which has
one black node.

194
00:14:20 --> 00:14:23
There are other paths here,
which are longer.

195
00:14:23 --> 00:14:25
But they still only have one
black node.

196
00:14:25 --> 00:14:28
So, if we just sort of ignore
the red nodes,

197
00:14:28 --> 00:14:31
all these paths have the same
length.

198
00:14:31 --> 00:14:34
OK: 18 should be bigger
hopefully, black height of two

199
00:14:34 --> 00:14:38
because each of these paths now
has one black node here,

200
00:14:38 --> 00:14:41
one black node in leaves,
or one black note here,

201
00:14:41 --> 00:14:46
and one black node in the
leaves.

202
00:14:46 --> 00:14:49
And finally,
the root should have a black

203
00:14:49 --> 00:14:53
height of two.
It's easier to see over here,

204
00:14:53 --> 00:14:56
I guess.
Each of these paths has two

205
00:14:56 --> 00:15:00
black nodes.
Same over here.

206
00:15:00 --> 00:15:02
OK, so hopefully these
properties make sense.

207
00:15:02 --> 00:15:06
We didn't check all of them.
Every red node has a black

208
00:15:06 --> 00:15:08
parent.
If you look at all of these

209
00:15:08 --> 00:15:11
paths, we sort of alternate,
red, black at most.

210
00:15:11 --> 00:15:13
Or we have just a bunch of
blacks.

211
00:15:13 --> 00:15:15
But we never repeat two reds in
a row.

212
00:15:15 --> 00:15:19
The root and the leaves are
black that we used pretty much

213
00:15:19 --> 00:15:22
by definition.
Every node is red or black.

214
00:15:22 --> 00:15:24
OK, that's easy.
This is a particular set of

215
00:15:24 --> 00:15:27
properties.
It may seem a bit arbitrary at

216
00:15:27 --> 00:15:30
this point.
They will make a lot more sense

217
00:15:30 --> 00:15:34
as we see what consequences they
have.

218
00:15:34 --> 00:15:37
But there are a couple of goals
that we are trying to achieve

219
00:15:37 --> 00:15:40
here.
One is that these properties

220
00:15:40 --> 00:15:43
should force the tree to have
logarithmic height,

221
00:15:43 --> 00:15:45
order log n height.
And, they do,

222
00:15:45 --> 00:15:48
although that's probably not
obvious at this point.

223
00:15:48 --> 00:15:51
It follows mainly from all the
properties.

224
00:15:51 --> 00:15:53
Three and four are the main
ones.

225
00:15:53 --> 00:15:56
But you pretty much need all of
them.

226
00:15:56 --> 00:15:59
The other desire we have from
these properties is that they

227
00:15:59 --> 00:16:05
are somehow easy to maintain.
OK, I can create a tree in the

228
00:16:05 --> 00:16:07
beginning that has this
property.

229
00:16:07 --> 00:16:09
For example,
I could make,

230
00:16:09 --> 00:16:14
I have to be a little bit
careful, but certainly if I take

231
00:16:14 --> 00:16:19
a perfectly balanced binary tree
and make all of the nodes black,

232
00:16:19 --> 00:16:21
it will satisfy those
properties.

233
00:16:21 --> 00:16:25
OK, this is a red black tree.
OK, so it's not too hard to

234
00:16:25 --> 00:16:30
make any these properties hold
just from the beginning.

235
00:16:30 --> 00:16:34
The tricky part is to maintain
them.

236
00:16:34 --> 00:16:38
When I insert a node into this
tree, and delete a node for this

237
00:16:38 --> 00:16:40
tree, I want to make it not too
hard.

238
00:16:40 --> 00:16:43
In log n time,
I've got to be able to restore

239
00:16:43 --> 00:16:47
all these properties.
OK, that will be the hardest

240
00:16:47 --> 00:16:49
part.
The first thing we will do is

241
00:16:49 --> 00:16:53
prove that these properties
imply that the tree has to have

242
00:16:53 --> 00:16:56
height order log n.
Therefore, all searches and

243
00:16:56 --> 00:16:59
queries on a data structure will
run fast.

244
00:16:59 --> 00:17:03
The hard part will be to make
sure these properties stay true

245
00:17:03 --> 00:17:09
if they initially held true when
we make changes to the tree.

246
00:17:09 --> 00:17:17
So, let's look at the height of
a red black tree.

247
00:17:17 --> 00:17:34


248
00:17:34 --> 00:17:38
And from this we will start to
see where these properties come

249
00:17:38 --> 00:17:41
from, why we chose these
properties.

250
00:17:41 --> 00:18:06


251
00:18:06 --> 00:18:09
So, the claim is that the
height of a red black tree with

252
00:18:09 --> 00:18:13
n keys, so, I'm not saying nodes
here because I really only want

253
00:18:13 --> 00:18:17
to count the internal nodes,
not these extra leaves that

254
00:18:17 --> 00:18:20
we've added, has height,
at most, two times log of n

255
00:18:20 --> 00:18:24
plus one, so order log n.
But, we have a pretty precise

256
00:18:24 --> 00:18:28
bound of a factor of two.
There is a proof of this in the

257
00:18:28 --> 00:18:32
textbook by induction,
and you should read that.

258
00:18:32 --> 00:18:35
What I'm going to give us more
of a proof sketch.

259
00:18:35 --> 00:18:40
But you should read the proof
by induction because all the

260
00:18:40 --> 00:18:44
practice you can get with proof
by induction is good.

261
00:18:44 --> 00:18:49
The proof sketch on the other
hand gives a lot more intuition

262
00:18:49 --> 00:18:54
with what's going on with red
black trees and connects up with

263
00:18:54 --> 00:18:58
recitation on Friday.
So, let me tell you that

264
00:18:58 --> 00:19:02
instead.
I'm going to leave that board

265
00:19:02 --> 00:19:04
blank and go over here.

266
00:19:04 --> 00:19:30


267
00:19:30 --> 00:19:36
So, the first thing I'm going
to do, I'm going to manipulate

268
00:19:36 --> 00:19:41
this tree until it looks like
something that I know.

269
00:19:41 --> 00:19:48
The main change I'm going to
make is to merge each red node

270
00:19:48 --> 00:19:53
into its parent.
And we know that the parent of

271
00:19:53 --> 00:19:59
a red node must be black.
So, merge each red node into

272
00:19:59 --> 00:20:04
its black parent.
So, let's look at that here.

273
00:20:04 --> 00:20:08
So, I'm going to take this red
node, merge it into its parent,

274
00:20:08 --> 00:20:11
take this red node,
merge it into its path,

275
00:20:11 --> 00:20:14
and so on.
There's one up there which I

276
00:20:14 --> 00:20:17
can't reach.
But I'm going to redraw this

277
00:20:17 --> 00:20:21
picture now.
So, seven, so the top node now

278
00:20:21 --> 00:20:23
becomes, in some sense,
seven and 18.

279
00:20:23 --> 00:20:29
They got merged together,
but no one else joined them.

280
00:20:29 --> 00:20:31
Then, on the left,
we have three.

281
00:20:31 --> 00:20:35
OK, nothing joined that,
and there's some leaves as

282
00:20:35 --> 00:20:37
usual.
Now, if you look at,

283
00:20:37 --> 00:20:40
maybe, I'm going to have to
draw this.

284
00:20:40 --> 00:20:43
Uh-oh.
I heard that sound before.

285
00:20:43 --> 00:20:47
So, I'm merging these nodes
together, and I'm merging all of

286
00:20:47 --> 00:20:52
these nodes together because
each of these red nodes merges

287
00:20:52 --> 00:20:56
into that black node.
And, I'm merging these two

288
00:20:56 --> 00:20:59
nodes together.
So, I'm putting this red node

289
00:20:59 --> 00:21:06
into that black node.
So, now you can see from the

290
00:21:06 --> 00:21:12
root, which is now 7/18.
There are three children

291
00:21:12 --> 00:21:16
hanging off.
So, in that picture,

292
00:21:16 --> 00:21:23
I'd like to draw that fact
assuming I can get this board

293
00:21:23 --> 00:21:24
back down.
Good.

294
00:21:24 --> 00:21:31
So, between seven and 18,
I have this conglomerate node,

295
00:21:31 --> 00:21:37
eight, ten, 11.
And, there are four leaves

296
00:21:37 --> 00:21:42
hanging off of that node.
And, off to the right,

297
00:21:42 --> 00:21:49
after 18, I have a conglomerate
node, 22/26, and there are three

298
00:21:49 --> 00:21:54
leaves hanging off of there.
OK, kind of a weird tree

299
00:21:54 --> 00:22:00
because we dealt mainly with
binary trees so far,

300
00:22:00 --> 00:22:05
but this is a foreshadowing of
what will come on Friday.

301
00:22:05 --> 00:22:12
This is something called a
two-three-four tree.

302
00:22:12 --> 00:22:16
Any guesses why it's called a
two-three-four tree?

303
00:22:16 --> 00:22:20
Every node can have two,
three, or four kids,

304
00:22:20 --> 00:22:24
yeah, except the leaves.
They have zero.

305
00:22:24 --> 00:22:29
There is another nice property
of two-three-four trees maybe

306
00:22:29 --> 00:22:33
hinted at.
So, there's really no control

307
00:22:33 --> 00:22:39
over whether you have two
children or three children or

308
00:22:39 --> 00:22:43
four children.
But, there is another nice

309
00:22:43 --> 00:22:45
property.
Yeah?

310
00:22:45 --> 00:22:49
All of the leaves have the same
depth, exactly.

311
00:22:49 --> 00:22:54
All of these guys have the same
depth in the tree.

312
00:22:54 --> 00:23:00
Why is that?
Because of property four.

313
00:23:00 --> 00:23:03
On Friday, you will see just
how to maintain that property.

314
00:23:03 --> 00:23:07
But out of this transformation,
we get that all the leaves have

315
00:23:07 --> 00:23:09
the same depth:
because their depth,

316
00:23:09 --> 00:23:12
now, or let's say their height
in the tree is their black

317
00:23:12 --> 00:23:15
height.
And, the depth of these leaves

318
00:23:15 --> 00:23:17
will be the black height of the
root.

319
00:23:17 --> 00:23:20
We are you raising all the red
nodes, and we said if we look at

320
00:23:20 --> 00:23:24
a path, and we ignore all the
red nodes, then the number of

321
00:23:24 --> 00:23:26
black nodes along a path is the
same.

322
00:23:26 --> 00:23:31
Now we are basically just
leaving all the black nodes.

323
00:23:31 --> 00:23:39
And so, along all these paths
we'll have the same number of

324
00:23:39 --> 00:23:43
black nodes.
And therefore,

325
00:23:43 --> 00:23:49
every leaf will have the same
depth.

326
00:23:49 --> 00:23:55
Let me write down some of these
properties.

327
00:23:55 --> 00:24:04
So, every internal node has
between two and four children.

328
00:24:04 --> 00:24:10
And every leaf has the same
depth, namely,

329
00:24:10 --> 00:24:17
the black height of the root.

330
00:24:17 --> 00:24:28


331
00:24:28 --> 00:24:31
This is by property four.
OK, so this is telling us a

332
00:24:31 --> 00:24:34
lot.
So, essentially what this

333
00:24:34 --> 00:24:37
transformation is doing is
ignoring the red nodes.

334
00:24:37 --> 00:24:42
Then, if you just focus on the
black nodes, height equals black

335
00:24:42 --> 00:24:44
height.
And then, black height is

336
00:24:44 --> 00:24:49
telling us that all the root to
leaf paths have the same length.

337
00:24:49 --> 00:24:53
Therefore, all these nodes are
at the same level.

338
00:24:53 --> 00:24:57
Having leaves at the same level
as a good thing because it means

339
00:24:57 --> 00:25:02
that your tree is pretty much
balanced.

340
00:25:02 --> 00:25:05
If you have a tree where all
the nodes are branching,

341
00:25:05 --> 00:25:10
so, they'll have at least two
children, and all the leaves are

342
00:25:10 --> 00:25:13
at the same level,
that's pretty balanced.

343
00:25:13 --> 00:25:16
OK, we will prove some form of
that now.

344
00:25:16 --> 00:25:19
I'm going to call the height of
this tree h prime.

345
00:25:19 --> 00:25:22
The height of the original tree
is h.

346
00:25:22 --> 00:25:24
That's what we want to bound
here.

347
00:25:24 --> 00:25:27
So, the first thing is to bound
h prime.

348
00:25:27 --> 00:25:32
And then we want to relate h
and h prime.

349
00:25:32 --> 00:25:36
OK, so the first question is
how many leaves are there in

350
00:25:36 --> 00:25:39
this tree?
And, it doesn't really matter

351
00:25:39 --> 00:25:43
which tree I'm looking at
because I didn't really do

352
00:25:43 --> 00:25:46
anything to the leaves.
All the leaves are black.

353
00:25:46 --> 00:25:51
So the leaves didn't change.
How many leaves are there in

354
00:25:51 --> 00:25:53
this tree, and then therefore,
industry?

355
00:25:53 --> 00:25:54
Sorry?
Nine.

356
00:25:54 --> 00:25:58
Indeed, there are nine,
but I meant in general,

357
00:25:58 --> 00:26:03
sorry.
In this example there are nine.

358
00:26:03 --> 00:26:07
How many keys are there?
Eight.

359
00:26:07 --> 00:26:12
So, in general,
how do you write nine as a

360
00:26:12 --> 00:26:18
function of eight for large
values of nine or eight?

361
00:26:18 --> 00:26:20
Sorry?
Plus one, good,

362
00:26:20 --> 00:26:24
correct answer,
by guessing.

363
00:26:24 --> 00:26:30
n plus one.
OK, why is it n plus one?

364
00:26:30 --> 00:26:34
Let's look at the binary tree
case where we sort of understand

365
00:26:34 --> 00:26:37
what's going on?
Well, wherever you have a key,

366
00:26:37 --> 00:26:40
there are two branches.
And, that's not a very good

367
00:26:40 --> 00:26:43
argument.
OK, we have what is here called

368
00:26:43 --> 00:26:47
a branching binary tree.
Every internal node has exactly

369
00:26:47 --> 00:26:50
two children.
And, we are counting the number

370
00:26:50 --> 00:26:54
of leaves that you get from that
process in terms of the number

371
00:26:54 --> 00:26:58
of internal nodes.
The number of leaves in a tree,

372
00:26:58 --> 00:27:01
or a branching tree,
as always one plus the number

373
00:27:01 --> 00:27:05
of internal nodes.
You should know that.

374
00:27:05 --> 00:27:10
You can prove it by induction.
OK, so the number of leaves is

375
00:27:10 --> 00:27:14
n plus one.
It doesn't hold if you have a

376
00:27:14 --> 00:27:18
single child.
It holds if every internal node

377
00:27:18 --> 00:27:22
has a branching factor of two.
OK, this is a neither tree.

378
00:27:22 --> 00:27:27
And now, we want to pull out
some relation between the number

379
00:27:27 --> 00:27:32
of leaves and the height of the
tree.

380
00:27:32 --> 00:27:35
So, what's a good relation to
use here?

381
00:27:35 --> 00:27:38
We know exactly how many leaves
there are.

382
00:27:38 --> 00:27:40
That will somehow connect us to
n.

383
00:27:40 --> 00:27:43
What we care about is the
height.

384
00:27:43 --> 00:27:46
And let's look at the height of
this tree.

385
00:27:46 --> 00:27:50
So, if I have a two-three-four
tree of height h prime,

386
00:27:50 --> 00:27:55
how many leaves could it have?
What's the minimum and maximum

387
00:27:55 --> 00:28:01
number of leaves it could have?
2^h to 4^h, or h prime.

388
00:28:01 --> 00:28:05
So, we also know in the
two-three-four tree,

389
00:28:05 --> 00:28:10
the number of leaves has to be
between four to the h prime,

390
00:28:10 --> 00:28:15
because at most I could branch
four ways in each node.

391
00:28:15 --> 00:28:21
And, it's at least two to the h
prime because I know that every

392
00:28:21 --> 00:28:25
node branches at least two ways.
That's key.

393
00:28:25 --> 00:28:31
So, I only care about one of
these, I think this one.

394
00:28:31 --> 00:28:34
So, I get that two to the h
prime is, at most,

395
00:28:34 --> 00:28:37
n plus one.
So the number of leaves is n

396
00:28:37 --> 00:28:39
plus one.
We know that exactly.

397
00:28:39 --> 00:28:42
So, we rewrite,
we take logs of both sides.

398
00:28:42 --> 00:28:45
It says h one is at most log of
n plus one.

399
00:28:45 --> 00:28:47
So, we have a nice,
balanced tree.

400
00:28:47 --> 00:28:51
This should be intuitive.
If I had every node branching

401
00:28:51 --> 00:28:54
two ways, and all the leaves at
the same level,

402
00:28:54 --> 00:28:58
that's a perfect tree.
It should be exactly log base

403
00:28:58 --> 00:29:03
two of n plus one,
and turns out not quite n.

404
00:29:03 --> 00:29:05
That should be the height of
the tree.

405
00:29:05 --> 00:29:08
Here, I might have even more
branching, which is making

406
00:29:08 --> 00:29:10
things even shallower in some
sense.

407
00:29:10 --> 00:29:13
So, I get more leaves out of
the same height.

408
00:29:13 --> 00:29:16
But that's only better for me.
That will only decrease the

409
00:29:16 --> 00:29:19
height in terms of the number of
leaves.

410
00:29:19 --> 00:29:21
n plus one here is the number
of leaves.

411
00:29:21 --> 00:29:23
So: cool.
That's an easy upper bound on

412
00:29:23 --> 00:29:27
the height of the tree.
Now, what we really care about

413
00:29:27 --> 00:29:30
is the height of this tree.
So, we want to relate h and h

414
00:29:30 --> 00:29:34
prime.
Any suggestions on how we might

415
00:29:34 --> 00:29:37
do that?
How do we know that the height

416
00:29:37 --> 00:29:41
of this reduced tree is not too
much smaller than this one.

417
00:29:41 --> 00:29:44
We know that this one is,
at most, log n.

418
00:29:44 --> 00:29:47
We want this to be,
at most, two log n plus one.

419
00:29:47 --> 00:29:50
We know the answer.
We've said the theorem.

420
00:29:50 --> 00:29:51
Sorry?
Right.

421
00:29:51 --> 00:29:55
So, property three tells us
that we can only have one red

422
00:29:55 --> 00:29:58
node for every black one.
We can, at most,

423
00:29:58 --> 00:30:04
alternate red and black.
So, if we look at one of these

424
00:30:04 --> 00:30:09
paths that goes from a root to a
leaf, the number of red nodes

425
00:30:09 --> 00:30:13
can be, at most,
half the length of the path.

426
00:30:13 --> 00:30:18
And we take the max overall
paths, that's the height of the

427
00:30:18 --> 00:30:21
tree.
So, we know that h is,

428
00:30:21 --> 00:30:26
at most, two times h prime,
or maybe it's easier to think

429
00:30:26 --> 00:30:28
of h prime is at least a half,
h.

430
00:30:28 --> 00:30:33
Assuming I got that right,
because at most a half of the

431
00:30:33 --> 00:30:38
nodes on any root to leaf path
--

432
00:30:38 --> 00:30:48


433
00:30:48 --> 00:30:52
-- are red.
So, at least half of them have

434
00:30:52 --> 00:30:56
to be black.
And, all-black nodes are

435
00:30:56 --> 00:31:01
captured in this picture so we
have this relation,

436
00:31:01 --> 00:31:04
and therefore,
h is, at most,

437
00:31:04 --> 00:31:08
two times log n plus one.
OK: pretty easy.

438
00:31:08 --> 00:31:12
But you have to remember,
this tree has to be balanced,

439
00:31:12 --> 00:31:15
and they are not too far away
from each other.

440
00:31:15 --> 00:31:18
OK, so in Friday's recitation,
you will see how to manipulate

441
00:31:18 --> 00:31:21
trees with this form.
There is a cool way to do it.

442
00:31:21 --> 00:31:25
That's two-three-four trees.
Today, we're going to see how

443
00:31:25 --> 00:31:28
to manipulate trees in this form
as red black trees.

444
00:31:28 --> 00:31:31
And, you'll see today's
lecture, and you'll see Friday's

445
00:31:31 --> 00:31:36
recitation, and they won't
really seem to relate at all.

446
00:31:36 --> 00:31:40
But they're the same,
just a bit hidden.

447
00:31:40 --> 00:31:47
OK, so this is good news.
We now know that all red black

448
00:31:47 --> 00:31:53
trees are balanced.
So as long as we can make sure

449
00:31:53 --> 00:32:00
that our tree stays a red black
tree, we'll be OK.

450
00:32:00 --> 00:32:05
We'll be OK in the sense that
the height is always log n.

451
00:32:05 --> 00:32:10
And therefore,
queries in a red black tree,

452
00:32:10 --> 00:32:15
so queries are things like
search, find a given key,

453
00:32:15 --> 00:32:18
find the minimum,
find the maximum,

454
00:32:18 --> 00:32:22
find a successor,
find a predecessor.

455
00:32:22 --> 00:32:28
These are all queries that we
know how to support in a binary

456
00:32:28 --> 00:32:35
search tree.
And we know how to do them in

457
00:32:35 --> 00:32:44
order height time.
And the height here is log n so

458
00:32:44 --> 00:32:53
we know that all of these
operations take order log n in a

459
00:32:53 --> 00:32:58
red black tree.
OK --

460
00:32:58 --> 00:33:13


461
00:33:13 --> 00:33:18
So, queries are easy.
We are done with queries,

462
00:33:18 --> 00:33:22
just from balance:
not a surprise.

463
00:33:22 --> 00:33:29
We know that balances is good.
The hard part for us will be to

464
00:33:29 --> 00:33:33
do updates.
And in this context,

465
00:33:33 --> 00:33:35
updates means insert and
delete.

466
00:33:35 --> 00:33:38
In general, and a data
structure, we talk about queries

467
00:33:38 --> 00:33:42
which ask questions about the
data in the structure,

468
00:33:42 --> 00:33:45
and updates which modify the
data in the structure.

469
00:33:45 --> 00:33:48
And most of the time here,
we are always thinking about

470
00:33:48 --> 00:33:51
dynamic sets.
So, you can change the dynamics

471
00:33:51 --> 00:33:53
set by adding or deleting an
element.

472
00:33:53 --> 00:33:55
You can ask all sorts of
questions.

473
00:33:55 --> 00:33:59
In priority queues,
there were other updates like

474
00:33:59 --> 00:34:02
delete Min.
Here we have find Min,

475
00:34:02 --> 00:34:05
but we could then delete it.
Typically these are the

476
00:34:05 --> 00:34:09
operations we care about.
And we'll talk about updates to

477
00:34:09 --> 00:34:12
include those of these,
and queries to include all of

478
00:34:12 --> 00:34:15
these, or whatever happens to be
relevant.

479
00:34:15 --> 00:34:18
In problem sets especially,
you'll see all sorts of

480
00:34:18 --> 00:34:21
different queries that you can
support.

481
00:34:21 --> 00:34:23
OK, so how do we support
updates?

482
00:34:23 --> 00:34:27
Well, we have binary search
tree insert, which we call tree

483
00:34:27 --> 00:34:30
insert.
We have binary search tree

484
00:34:30 --> 00:34:33
delete, tree delete.
They will preserve the binary

485
00:34:33 --> 00:34:36
search tree property,
but we know they don't

486
00:34:36 --> 00:34:39
necessarily preserve balance.
We can insert a bunch of nodes.

487
00:34:39 --> 00:34:42
Just keep adding new minimum
elements and you will get a

488
00:34:42 --> 00:34:45
really long path off the end.
So, presumably,

489
00:34:45 --> 00:34:49
they do not preserve the red
black properties because we know

490
00:34:49 --> 00:34:51
red black implies balance.
In particular,

491
00:34:51 --> 00:34:54
they won't satisfy property
one, which I've erased,

492
00:34:54 --> 00:34:56
which is every node is red or
black.

493
00:34:56 --> 00:34:59
It'll add a node,
and not assign it a color.

494
00:34:59 --> 00:35:01
So, we've got to assign it a
color.

495
00:35:01 --> 00:35:04
And, as soon as we do that,
we'll probably violate some

496
00:35:04 --> 00:35:06
other property.
And then we have to fix that

497
00:35:06 --> 00:35:09
property, and so on.
So, it's a bit tricky,

498
00:35:09 --> 00:35:14
but you play around with it and
it's not too hard.

499
00:35:14 --> 00:35:18
OK, so updates must modify the
tree.

500
00:35:18 --> 00:35:27
And to preserve the red black
properties, they're going to do

501
00:35:27 --> 00:35:34
it in three different kinds of
modifications.

502
00:35:34 --> 00:35:37
The first thing we will indeed
do is just use the BST

503
00:35:37 --> 00:35:40
operation, tree insert or tree
delete.

504
00:35:40 --> 00:35:42
That's something we know how to
do.

505
00:35:42 --> 00:35:45
Let's just do it.
We are going to have to change

506
00:35:45 --> 00:35:48
the colors of some of the nodes.
In particular,

507
00:35:48 --> 00:35:52
the one that we insert better
be colored somehow.

508
00:35:52 --> 00:35:54
And in general,
if we just rip out a node,

509
00:35:54 --> 00:36:00
we are going to have to recolor
it, recolor some nearby nodes.

510
00:36:00 --> 00:36:03
There is one other kind of
operation we're going to do.

511
00:36:03 --> 00:36:06
So, recoloring just means set
to red or black.

512
00:36:06 --> 00:36:09
The other thing you might do is
rearrange the tree,

513
00:36:09 --> 00:36:12
change the pointers,
change the links from one node

514
00:36:12 --> 00:36:15
to another.
And, we're going to do that at

515
00:36:15 --> 00:36:18
the very structured way.
And, this is one of the main

516
00:36:18 --> 00:36:21
reasons that red black trees are
interesting.

517
00:36:21 --> 00:36:24
The kinds of changes they make
are very simple,

518
00:36:24 --> 00:36:27
and they also don't make very
many of them.

519
00:36:27 --> 00:36:32
So, they're called rotations.
So, here's a rotation.

520
00:36:32 --> 00:36:46


521
00:36:46 --> 00:36:48
OK, this is a way of drawing a
generic part of a tree.

522
00:36:48 --> 00:36:50
We have two nodes,
A and B.

523
00:36:50 --> 00:36:53
There is some subtrees hanging
off, which we draw as triangles.

524
00:36:53 --> 00:36:56
We don't know how big they are.
We know they better all have

525
00:36:56 --> 00:37:00
the same black height if it's a
red black tree.

526
00:37:00 --> 00:37:02
But in general,
it just looks like this.

527
00:37:02 --> 00:37:06
There is some parent,
and there's some rest of the

528
00:37:06 --> 00:37:08
tree out here which we don't
draw.

529
00:37:08 --> 00:37:12
I'll give these subtrees names,
Greek names,

530
00:37:12 --> 00:37:13
alpha, beta,
gamma.

531
00:37:13 --> 00:37:16
And, I'll define the operation
right rotate of B.

532
00:37:16 --> 00:37:21
So general, if I have a node,
B, I look at it and I want to

533
00:37:21 --> 00:37:24
do it right rotation,
I look at its left child enjoy

534
00:37:24 --> 00:37:30
this picture called the subtrees
of those two nodes.

535
00:37:30 --> 00:37:34
And, I create this tree.

536
00:37:34 --> 00:37:45


537
00:37:45 --> 00:37:47
So, all I've done is turn this
edge 90°.

538
00:37:47 --> 00:37:51
What was the parent of B is now
the parent of A.

539
00:37:51 --> 00:37:54
A is now the new parent of B.
The subtrees rearrange.

540
00:37:54 --> 00:37:59
Before, they were both subtrees
of, these two were subtrees of

541
00:37:59 --> 00:38:02
A.
And, gamma was a subtree of B.

542
00:38:02 --> 00:38:06
Gamma is still a subtree of B,
and alpha still is a subtree of

543
00:38:06 --> 00:38:08
A.
But, beta switched to being a

544
00:38:08 --> 00:38:11
subtree of B.
OK, the main thing we want to

545
00:38:11 --> 00:38:15
check here is that this
operation preserves the binary

546
00:38:15 --> 00:38:19
search tree property.
Remember, the binary search

547
00:38:19 --> 00:38:23
tree property says that all the
elements in the left subtree of

548
00:38:23 --> 00:38:28
a node are less than or equal to
the node, and all the elements

549
00:38:28 --> 00:38:34
in the right subtree are greater
than or equal to that value.

550
00:38:34 --> 00:38:37
So, in particular,
if we take some node,

551
00:38:37 --> 00:38:40
little a in alpha,
little b in beta,

552
00:38:40 --> 00:38:45
and little c in gamma,
then a is less than or equal to

553
00:38:45 --> 00:38:50
capital A, is less than or equal
to little b, is less than or

554
00:38:50 --> 00:38:54
equal to capital B,
is less than or equal to little

555
00:38:54 --> 00:38:57
c.
And, this is the condition both

556
00:38:57 --> 00:39:03
on the left side and on the
right side because Alpha is left

557
00:39:03 --> 00:39:06
of everything.
Beta is in between A and B,

558
00:39:06 --> 00:39:11
and gamma is after B.
And the same thing is true over

559
00:39:11 --> 00:39:12
here.
Beta is still,

560
00:39:12 --> 00:39:15
it's supposed to be all the
nodes that come between capital

561
00:39:15 --> 00:39:17
A and capital B.
So, this is good.

562
00:39:17 --> 00:39:20
We could definitely do this
operation, still have the binary

563
00:39:20 --> 00:39:23
search tree, and we are going to
use rotations in a particularly

564
00:39:23 --> 00:39:26
careful way to make sure that we
maintain all these properties.

565
00:39:26 --> 00:39:30
That's the hard part.
But, rotations will be our key.

566
00:39:30 --> 00:39:32
This was the right rotate
operation.

567
00:39:32 --> 00:39:35
The reverse operation is left
rotate.

568
00:39:35 --> 00:39:40
So, this is left rotate of A.
In general, of the two nodes

569
00:39:40 --> 00:39:43
that are involved,
we list the top one.

570
00:39:43 --> 00:39:47
So, its right rotate of B will
give you this.

571
00:39:47 --> 00:39:50
Left rotate of A will give you
this.

572
00:39:50 --> 00:39:54
So, these are reversible
operations, which feels good.

573
00:39:54 --> 00:39:58
The other thing is that they
only take constant time

574
00:39:58 --> 00:40:03
operations because we are only
changing a constant number of

575
00:40:03 --> 00:40:07
pointers.
As long as you know the node,

576
00:40:07 --> 00:40:11
B, that you are interested in,
you set the left pointer of B

577
00:40:11 --> 00:40:14
to be, if you want it to be
beta, so you set left of B to be

578
00:40:14 --> 00:40:16
right of A, and so on,
and so on.

579
00:40:16 --> 00:40:18
You make constant number of
those changes.

580
00:40:18 --> 00:40:22
You update the parents as well.
It's only a constant number of

581
00:40:22 --> 00:40:25
links that are changing,
so, a constant number of

582
00:40:25 --> 00:40:28
assignments you need to do.
So, you've probably seen

583
00:40:28 --> 00:40:37
rotations before.
But we are going to use them in

584
00:40:37 --> 00:40:47
a complicated way.
So, let's look at how to do

585
00:40:47 --> 00:40:56
insertion.
We'll see it three times in

586
00:40:56 --> 00:41:02
some sense.
First, I'll tell you the basic

587
00:41:02 --> 00:41:07
idea, which is pretty simple.
I mentioned some of it already.

588
00:41:07 --> 00:41:11
Then, we'll do it on an
example, feel it in our bones,

589
00:41:11 --> 00:41:15
and then we'll give the
pseudocode so that you could go

590
00:41:15 --> 00:41:18
home and implement it if you
wanted.

591
00:41:18 --> 00:41:20
OK, this is,
I should say,

592
00:41:20 --> 00:41:24
red black insert,
which in the book is called RB

593
00:41:24 --> 00:41:29
insert, not for root beer,
but for red black.

594
00:41:29 --> 00:41:32
OK, so the first thing we're
going to do, as I said,

595
00:41:32 --> 00:41:35
is binary search tree,
insert that node.

596
00:41:35 --> 00:41:39
So, x now becomes a new leaf.
We searched for x wherever it's

597
00:41:39 --> 00:41:42
supposed to go.
We create, I shouldn't call it

598
00:41:42 --> 00:41:45
a leaf now.
It's now at node hanging off.

599
00:41:45 --> 00:41:49
It's an internal node hanging
off one of the original nodes.

600
00:41:49 --> 00:41:53
Maybe we added it right here.
It now gets two new leaves

601
00:41:53 --> 00:41:57
hanging off of it.
It has no internal children.

602
00:41:57 --> 00:41:59
And, we get to pick a color for
it.

603
00:41:59 --> 00:42:03
And, we will pick the color
red.

604
00:42:03 --> 00:42:06
OK, why red?
We definitely have to pick one

605
00:42:06 --> 00:42:08
of two colors.
We could flip a coin.

606
00:42:08 --> 00:42:11
That might work,
but it's going to make our job

607
00:42:11 --> 00:42:15
even messier.
So, we are adding a new node.

608
00:42:15 --> 00:42:19
It's not a root or a leaf
presumably, so we don't really

609
00:42:19 --> 00:42:21
need it to be black by property
two.

610
00:42:21 --> 00:42:24
Property three,
every red node has a black

611
00:42:24 --> 00:42:26
parent.
That might be a problem.

612
00:42:26 --> 00:42:31
So, the problem is if its
parent is red.

613
00:42:31 --> 00:42:35
Then we violate property two.
The parent might be red,

614
00:42:35 --> 00:42:37
property three,
sorry.

615
00:42:37 --> 00:42:42
OK, the good news is that
property four is still true

616
00:42:42 --> 00:42:47
because property four is just
counting numbers of black nodes

617
00:42:47 --> 00:42:52
down various paths.
That's really the hard property

618
00:42:52 --> 00:42:55
to maintain.
If we just add a new red node,

619
00:42:55 --> 00:43:00
none of the black heights
change.

620
00:43:00 --> 00:43:05
None of the number of black
nodes along the path changes.

621
00:43:05 --> 00:43:11
So, this still has to hold.
The only thing we can violate

622
00:43:11 --> 00:43:14
is property three.
That's reasonable.

623
00:43:14 --> 00:43:20
We know we've got to violate
something at the beginning.

624
00:43:20 --> 00:43:24
We can't just do a binary
search tree insert.

625
00:43:24 --> 00:43:30
OK, so, let's give it a try on
this tree.

626
00:43:30 --> 00:43:34
I should say how we are going
to fix this.

627
00:43:34 --> 00:43:40
How do we fix property three?
We are going to move the

628
00:43:40 --> 00:43:47
violation of three up the tree.
So, we're going to start at

629
00:43:47 --> 00:43:51
node x, and move up towards the
root.

630
00:43:51 --> 00:43:55
This is via recoloring.
The only thing,

631
00:43:55 --> 00:44:01
initially, we'll do is
recoloring until we get to some

632
00:44:01 --> 00:44:09
point where we can fix the
violation using a rotation --

633
00:44:09 --> 00:44:20


634
00:44:20 --> 00:44:24
-- and probably also
recoloring.

635
00:44:24 --> 00:44:32
OK, so let's see this algorithm
in action.

636
00:44:32 --> 00:44:41
I want to copy this tree,
and you are going to have to

637
00:44:41 --> 00:44:49
copy it, too.
So, I'll just redraw it instead

638
00:44:49 --> 00:44:59
of modifying that diagram.
So, we have this nice red black

639
00:44:59 --> 00:45:05
tree.
And, we'll try inserting a new

640
00:45:05 --> 00:45:10
value of 15.
22 black.

641
00:45:10 --> 00:45:16
22 is the new black.
OK, that should be the same

642
00:45:16 --> 00:45:20
tree.
So now, I'm choosing the number

643
00:45:20 --> 00:45:26
15 to insert,
because that will show a fairly

644
00:45:26 --> 00:45:32
interesting insertion.
Sometimes, the insertion

645
00:45:32 --> 00:45:36
doesn't take very much work.
We just do the rotation and

646
00:45:36 --> 00:45:39
we're done.
I just like to look at an

647
00:45:39 --> 00:45:42
interesting case.
So, we insert 15.

648
00:45:42 --> 00:45:45
15 is bigger than seven.
It's less than 18.

649
00:45:45 --> 00:45:49
It's bigger than ten.
It's bigger than 11.

650
00:45:49 --> 00:45:53
So, 15 goes here.
So, we add a new red node of

651
00:45:53 --> 15.


652
15. --> 00:45:55
And, it has two black leaves

653
00:45:55 --> 00:45:59
hanging off of it,
replaced one black leaf.

654
00:45:59 --> 00:46:02
Now we have two.
OK, now, we violate property

655
00:46:02 --> 00:46:09
three because we added a new red
child of a red node.

656
00:46:09 --> 00:46:13
So, now we have two consecutive
red nodes in a root to leaf

657
00:46:13 --> 00:46:16
path.
We'd like to make this black,

658
00:46:16 --> 00:46:20
but that would screw up the
black heights because now this

659
00:46:20 --> 00:46:25
node would have one black node
over here, and two black nodes

660
00:46:25 --> 00:46:27
down this path.
So, that's not good.

661
00:46:27 --> 00:46:32
What can we do?
Well, let's try to re-color.

662
00:46:32 --> 00:46:34
Yes.
This always takes a little

663
00:46:34 --> 00:46:37
while to remember.
So, our fix is going to be to

664
00:46:37 --> 00:46:40
recolor.
And, the first thing that

665
00:46:40 --> 00:46:44
struck me, which doesn't work,
is we try to recolor around

666
00:46:44 --> 00:46:46
here.
It doesn't look so good because

667
00:46:46 --> 00:46:51
we've got red stuff out here,
but we've got a black node over

668
00:46:51 --> 00:46:53
here.
So we can't make this one red,

669
00:46:53 --> 00:46:56
and this one black.
It wouldn't quite work.

670
00:46:56 --> 00:47:00
If we look up a little higher
at the grandparent of 15 up

671
00:47:00 --> 00:47:06
here, we have a black node here
and two red children.

672
00:47:06 --> 00:47:08
That's actually pretty good
news because we could,

673
00:47:08 --> 00:47:12
instead, make that two black
children and a red parent.

674
00:47:12 --> 00:47:14
Locally, that's going to be
fine.

675
00:47:14 --> 00:47:17
It's not going to change any
black heights because any path

676
00:47:17 --> 00:47:21
that went through these nodes
before will still go through the

677
00:47:21 --> 00:47:24
same number of black nodes.
Instead of going through a

678
00:47:24 --> 00:47:27
black node always here,
it will go through a black node

679
00:47:27 --> 00:47:30
either here or here because
paths always go down to the

680
00:47:30 --> 00:47:34
leaves.
So, that's what we're going to

681
00:47:34 --> 00:47:38
do, recolor these guys.
And, we will get ten,

682
00:47:38 --> 00:47:40
which is red.
We'll get eight,

683
00:47:40 --> 00:47:43
which is black,
11 which is black,

684
00:47:43 --> 00:47:48
and these things don't change.
Everything else doesn't change.

685
00:47:48 --> 00:47:53
We are going to leave 15 red.
It's no longer in violation.

686
00:47:53 --> 00:47:57
15 is great because now its
parent is black.

687
00:47:57 --> 00:48:02
We now have a new violation up
here with 18 because 18 is also

688
00:48:02 --> 00:48:07
red.
That's the only violation we

689
00:48:07 --> 00:48:10
have.
In general, we'll have,

690
00:48:10 --> 00:48:17
at most, one violation at any
time until we fix it.

691
00:48:17 --> 00:48:20
Then we'll have zero
violations.

692
00:48:20 --> 00:48:27
OK, so, now we have a violation
between ten and 18:

693
00:48:27 --> 00:48:33
somehow always counterintuitive
to me.

694
00:48:33 --> 00:48:35
I had to look at the cheat
sheet again.

695
00:48:35 --> 00:48:37
Really?
No, OK, good.

696
00:48:37 --> 00:48:40
I was going to say,
we can't recolor anymore.

697
00:48:40 --> 00:48:41
Good.
I'm not that bad.

698
00:48:41 --> 00:48:45
So, what we'd like to do is,
again, look at the grandparent

699
00:48:45 --> 00:48:49
of ten, which is now seven,
the root of the tree.

700
00:48:49 --> 00:48:51
It is black,
but one of its children is

701
00:48:51 --> 00:48:53
black.
The other is red.

702
00:48:53 --> 00:48:57
So, we can't play the same game
of taking the blackness of

703
00:48:57 --> 00:49:02
seven, and moving it down to the
two children.

704
00:49:02 --> 00:49:04
Never mind that the root is
supposed to stay black.

705
00:49:04 --> 00:49:06
We'll ignore that property for
now.

706
00:49:06 --> 00:49:09
We can't make these two black
and make this one red,

707
00:49:09 --> 00:49:11
because then we'd get an
imbalance.

708
00:49:11 --> 00:49:14
This was already black.
So now, paths going down here

709
00:49:14 --> 00:49:17
will have one fewer black node
than paths going out here.

710
00:49:17 --> 00:49:20
So, we can't just recolor seven
and its children.

711
00:49:20 --> 00:49:22
So, instead,
we've got to do a rotation.

712
00:49:22 --> 00:49:26
We'd better be near the end.
So, what I will do is rotate

713
00:49:26 --> 00:49:28
this edge.
I'm going to rotate eight to

714
00:49:28 --> 00:49:35
the right.
So that's the next operation:

715
00:49:35 --> 00:49:39
rotate right of 18.

716
00:49:39 --> 00:50:03


717
00:50:03 --> 00:50:07
We'll delete one more operation
after this.

718
00:50:07 --> 00:50:11
So, we rotate right 18.
So, the root stays the same:

719
00:50:11 --> 00:50:14
seven, three,
its children.

720
00:50:14 --> 00:50:18
Now, the right child of seven
is no longer 18.

721
00:50:18 --> 00:50:22
It's now ten.
18 becomes the red child of

722
00:50:22 --> 00:50:25
ten.
OK, we have eight over here

723
00:50:25 --> 00:50:33
with its two children.
11 and 15: that subtree fits in

724
00:50:33 --> 00:50:37
between ten and 18.
So, it goes here:

725
00:50:37 --> 00:50:42
11 and 15.
And then, there's the right

726
00:50:42 --> 00:50:47
subtree.
Everything to the right of 18,

727
00:50:47 --> 00:50:51
that goes over here:
22 and 26.

728
00:50:51 --> 00:50:58
And hopefully I'm not changing
any colors during that

729
00:50:58 --> 00:51:04
operation.
If I did, let me know.

730
00:51:04 --> 00:51:06
OK, it looks good.
So, I still have this

731
00:51:06 --> 00:51:09
violation, still in trouble
between ten and 18.

732
00:51:09 --> 00:51:12
But, I've made this straighter.
OK, that's what we want to do,

733
00:51:12 --> 00:51:15
it turns out,
is make the connection between

734
00:51:15 --> 00:51:17
18, the violator,
and its grandparent,

735
00:51:17 --> 00:51:20
a straight connection:
two rights or two lefts.

736
00:51:20 --> 00:51:22
Here we had to zigzag right,
left.

737
00:51:22 --> 00:51:25
We like to make it straight.
OK, it doesn't look like a much

738
00:51:25 --> 00:51:27
more balanced tree that this
one.

739
00:51:27 --> 00:51:31
In fact, it looks a little
worse.

740
00:51:31 --> 00:51:36
What we can do is now rotate
these guys, or rather,

741
00:51:36 --> 00:51:40
rotate this edge.
I'm going to rotate seven to

742
00:51:40 --> 00:51:46
the left, make ten the root,
and that things will start to

743
00:51:46 --> 00:51:50
look balanced.
This is a rotate left of seven.

744
00:51:50 --> 00:51:57
And, I'm also going to do some
recoloring at the same time just

745
00:51:57 --> 00:52:02
to save me drawing one more
picture because the root has to

746
00:52:02 --> 00:52:07
be black.
I'm going to make 10 black

747
00:52:07 --> 00:52:11
immediately.
I'll make seven red.

748
00:52:11 --> 00:52:16
That's the change.
And that the rest is just a

749
00:52:16 --> 00:52:20
rotation.
So, we have 18 over here.

750
00:52:20 --> 00:52:25
I think I actually have to
rotate to keep some red

751
00:52:25 --> 00:52:31
blackness here.
Eight comes between seven and

752
00:52:31 --> 00:52:34
ten.
So it goes here.

753
00:52:34 --> 00:52:40
11 goes between ten and 18,
so it goes here.

754
00:52:40 --> 00:52:46
22 and 26 come after 18.
Now, if I'm lucky,

755
00:52:46 --> 00:52:52
I should satisfy all of
properties that I want.

756
00:52:52 --> 00:52:58
OK, now, if I'm lucky,
I should satisfy all the

757
00:52:58 --> 00:53:04
properties that I want.
Every node is red or black.

758
00:53:04 --> 00:53:08
Every black node has a child.
This is the last place we

759
00:53:08 --> 00:53:11
change.
Red nodes have black children,

760
00:53:11 --> 00:53:14
and all the black heights
should be well defined.

761
00:53:14 --> 00:53:18
For every node,
the number of black nodes along

762
00:53:18 --> 00:53:20
any node to leaf path is the
same.

763
00:53:20 --> 00:53:23
And you check,
that was true before,

764
00:53:23 --> 00:53:27
and I did a little bit of
trickery with the recoloring

765
00:53:27 --> 00:53:30
here.
But it's still true.

766
00:53:30 --> 00:53:34
I mean, you can check that just
locally around this rotation.

767
00:53:34 --> 00:53:36
OK, we'll do that in a little
bit.

768
00:53:36 --> 00:53:40
For now, it's just an example.
It's probably not terribly

769
00:53:40 --> 00:53:44
clear where these re-colorings
and rotations come from

770
00:53:44 --> 00:53:48
necessarily, but it worked,
and it at least convinces you

771
00:53:48 --> 00:53:52
that it's possible.
And now, we'll give a general

772
00:53:52 --> 00:53:55
algorithm for doing it.
Any questions before we go on?

773
00:53:55 --> 00:53:59
So, it's not exactly,
I mean, just writing of the

774
00:53:59 --> 00:54:03
algorithm is not terribly
intuitive.

775
00:54:03 --> 00:54:06
Red black trees of the sort of
thing where you play around a

776
00:54:06 --> 00:54:07
bit.
You say, OK,

777
00:54:07 --> 00:54:10
I'm going to just think about
recoloring and rotations.

778
00:54:10 --> 00:54:12
Let's restrict myself to those
operations.

779
00:54:12 --> 00:54:14
What could I do?
Well, I'll try to recolor.

780
00:54:14 --> 00:54:17
If that works great,
it pushes the problem up

781
00:54:17 --> 00:54:19
higher.
And, there's only log n levels,

782
00:54:19 --> 00:54:22
order log n levels,
so that's going to take order

783
00:54:22 --> 00:54:23
log n time.
At some point,

784
00:54:23 --> 00:54:25
I'll get stuck.
I can't recolor anymore.

785
00:54:25 --> 00:54:28
Then it turns out,
a couple of rotations will do

786
00:54:28 --> 00:54:32
it.
Always, two rotations will

787
00:54:32 --> 00:54:36
suffice.
And you just play with it,

788
00:54:36 --> 00:54:40
and that turns out to work.
And here's how.

789
00:54:40 --> 00:54:45
OK, so let's suppose we have a
red black tree.

790
00:54:45 --> 00:54:48
And value x,
we want to insert.

791
00:54:48 --> 00:54:53
Here's the algorithm.
First, we insert it into the

792
00:54:53 --> 00:54:55
BST.
So that we know.

793
00:54:55 --> 00:55:01
Then, we color the node red.
And here, I'm going to use a

794
00:55:01 --> 00:55:08
slightly more precise notation.
Color is a field of x.

795
00:55:08 --> 00:55:14
And now, we are going to walk
our way up the tree with a while

796
00:55:14 --> 00:55:21
loop until we get to the root,
or until we reach a black node.

797
00:55:21 --> 00:55:26
So, in general,
x initially is going to be the

798
00:55:26 --> 00:55:32
element that we inserted.
But, we're going to move x up

799
00:55:32 --> 00:55:36
the tree.
If ever we find that x is a

800
00:55:36 --> 00:55:40
black node, we're happy because
maybe its parent is red.

801
00:55:40 --> 00:55:42
Maybe it isn't.
I don't care.

802
00:55:42 --> 00:55:45
Black nodes can have
arbitrarily colored parents.

803
00:55:45 --> 00:55:48
It's red nodes that we worry
about.

804
00:55:48 --> 00:55:51
So, if x is red,
we have to keep doing this

805
00:55:51 --> 00:55:54
loop.
Of course, I just wrote the

806
00:55:54 --> 00:55:56
wrong one.
While the color is red,

807
00:55:56 --> 00:56:03
we're going to keep doing this.
So, there are three cases,

808
00:56:03 --> 00:56:07
or six, depending on how you
count.

809
00:56:07 --> 00:56:13
That's what makes this a little
bit tricky to memorize.

810
00:56:13 --> 00:56:18
OK, but there are some
symmetric situations.

811
00:56:18 --> 00:56:23
Let me draw them.
What we care about,

812
00:56:23 --> 00:56:27
I've argued,
is between x and its

813
00:56:27 --> 00:56:32
grandparent.
So, I'm using p of x here to

814
00:56:32 --> 00:56:36
denote parent of x just because
it's shorter.

815
00:56:36 --> 00:56:40
So, p of x is x's grandparent.
Left of p of x is the left

816
00:56:40 --> 00:56:43
child.
So, what I'm interested in is I

817
00:56:43 --> 00:56:46
look at x.
And, if I don't assign any

818
00:56:46 --> 00:56:51
directions, x is the child of
some p of x, and p of x is the

819
00:56:51 --> 00:56:55
child of the grandparent,
p of p of x.

820
00:56:55 --> 00:56:57
Now, these edges aren't
vertical.

821
00:56:57 --> 00:57:02
They are either left or right.
And, I care about which one.

822
00:57:02 --> 00:57:05
In particular,
I'm looking at whether the

823
00:57:05 --> 00:57:09
parent is the left child of the
grandparent.

824
00:57:09 --> 00:57:15
So, I want to know,
does it look like this?

825
00:57:15 --> 00:57:19
OK, and I don't know whether x
is to the left or to the right

826
00:57:19 --> 00:57:22
of the parent.
But, is parent of x the left

827
00:57:22 --> 00:57:25
child of p of x,
or is it the right child?

828
00:57:25 --> 00:57:28
And these two cases are totally
symmetric.

829
00:57:28 --> 00:57:31
But I need to assume it's one
way or the other.

830
00:57:31 --> 00:57:35
Otherwise, I can't draw the
pictures.

831
00:57:35 --> 00:57:39
OK, so this will be,
let's call it category A.

832
00:57:39 --> 00:57:44
And, this is category B.
And, I'm going to tell you what

833
00:57:44 --> 00:57:48
to do in category A.
And category B is symmetric.

834
00:57:48 --> 00:57:52
You just flip left and right.
OK, so this is A.

835
00:57:52 --> 00:57:56
So, within category A,
there are three cases.

836
00:57:56 --> 00:58:01
And within category B,
there is the same three cases,

837
00:58:01 --> 00:58:06
just reversed.
So, we're going to do is look

838
00:58:06 --> 00:58:09
at the other child of the
grandparent.

839
00:58:09 --> 00:58:14
This is one reason why we sort
of need to know which way we are

840
00:58:14 --> 00:58:17
looking.
If the parent of x is the left

841
00:58:17 --> 00:58:21
child of the grandparent,
we're going to look at the

842
00:58:21 --> 00:58:27
other child of the grandparent,
which would be the right child

843
00:58:27 --> 00:58:31
of the grandparent,
call that node y.

844
00:58:31 --> 00:58:34
This is also known as the uncle
or the aunt of x,

845
00:58:34 --> 00:58:37
depending on whether y is male
or female.

846
00:58:37 --> 00:58:40
OK, so this is uncle or aunt.
Unfortunately,

847
00:58:40 --> 00:58:44
in English, there is no
gender-free version of this as

848
00:58:44 --> 00:58:47
far as I know.
There's parent and child,

849
00:58:47 --> 00:58:51
but no uncle-aunt.
I'm sure we could come up with

850
00:58:51 --> 00:58:53
one.
I'm not going to try.

851
00:58:53 --> 00:58:57
It's going to sound bad.
OK, so why do I care about y?

852
00:58:57 --> 00:59:03
Because, I want to see if I can
do this recoloring step.

853
00:59:03 --> 00:59:06
The recoloring idea was,
well, the grandparents,

854
00:59:06 --> 00:59:09
let's say it's black.
If I can push the blackness of

855
00:59:09 --> 00:59:12
the grandparent down into the
two children,

856
00:59:12 --> 00:59:15
then if both of these are red,
in other words,

857
00:59:15 --> 00:59:18
then I'd be happy.
Then I'd push the problem up.

858
00:59:18 --> 00:59:20
This guy is now red.
This guy is black.

859
00:59:20 --> 00:59:24
So these two are all right.
This one may violate the great

860
00:59:24 --> 00:59:27
grandparent.
But we will just keep going up,

861
00:59:27 --> 00:59:30
and that will be fine.
Today, if we're lucky,

862
00:59:30 --> 00:59:35
y is red.
Then we can just do recoloring.

863
00:59:35 --> 00:59:41
So, if the color of y is red,
then we will recolor.

864
00:59:41 --> 00:59:49
And, I'm going to defer this to
a picture called case one.

865
00:59:49 --> 00:59:54
OK, let me first tell you how
the cases breakup,

866
00:59:54 --> 1:00:00
and then we will see how they
work.

867
1:00:00 --> 1:00:16


868
1:00:16 --> 1:00:23.546
So, if we're not in case one,
so this L should be aligned

869
1:00:23.546 --> 1:00:29.744
with that, then,
then we are either in case two

870
1:00:29.744 --> 1:00:35
or three.
So, here's the dichotomy.

871
1:00:35 --> 1:00:39.066
It turns out we've actually
seen all of the cases,

872
1:00:39.066 --> 1:00:43.299
maybe not A versus B,
but we've seen the case of the

873
1:00:43.299 --> 1:00:46.287
very beginning where we just
recolor.

874
1:00:46.287 --> 1:00:49.69
That's case one.
The next thing we saw is,

875
1:00:49.69 --> 1:00:54.338
well, it's kind of annoying
that the grandparent and ten,

876
1:00:54.338 --> 1:00:57.159
so seven and ten were not
straight.

877
1:00:57.159 --> 1:01:01.226
They were zigzagged.
So, case two is when they are

878
1:01:01.226 --> 1:01:04.546
zigzagged.
It turns out if x is the right

879
1:01:04.546 --> 1:01:08.364
child of its parent,
and the parent is the left

880
1:01:08.364 --> 1:01:12.929
child of the grandparent,
that's a we've assumed so far,

881
1:01:12.929 --> 1:01:18.972
that is case two.
OK, the other case is that x is

882
1:01:18.972 --> 1:01:24.63
the left child of its parent.
So, then we have a left chain,

883
1:01:24.63 --> 1:01:27.698
x, parent of x,
grandparent of x.

884
1:01:27.698 --> 1:01:32.881
That is case three.
OK, I did not write else here

885
1:01:32.881 --> 1:01:38.247
because what case two does is it
reduces to case three.

886
1:01:38.247 --> 1:01:42.619
So, in case two,
we are going to do the stuff

887
1:01:42.619 --> 1:01:46.892
that's here.
And then, we're going to do the

888
1:01:46.892 --> 1:01:49.475
stuff here.
For case three,

889
1:01:49.475 --> 1:01:53.549
we just do the stuff here.
Or in case one,

890
1:01:53.549 --> 1:01:58.816
we just do the stuff here.
And then, that finishes the

891
1:01:58.816 --> 1:02:03.486
three cases on the A side,
then back to this if.

892
1:02:03.486 --> 1:02:06.169
We say else,
this is case B,

893
1:02:06.169 --> 1:02:11.236
which is the same as A,
but reversing the notions of

894
1:02:11.236 --> 1:02:17
left and right,
OK, in the natural way.

895
1:02:17 --> 1:02:20.375
Every time we write left of
something, we instead write

896
1:02:20.375 --> 1:02:22.5
right of something,
and vice versa.

897
1:02:22.5 --> 1:02:25.5
So, this is really just
flipping everything over.

898
1:02:25.5 --> 1:02:29.187
We'll just focus on category A.
And, let's see what we do in

899
1:02:29.187 --> 1:02:33
each of the three cases.
We've seen it in an example.

900
1:02:33 --> 1:02:38.212
But let's do it generically.
Let's do it here.

901
1:02:38.212 --> 1:02:43.424
Sorry, there's one more line to
the algorithm,

902
1:02:43.424 --> 1:02:48.057
I should say.
It's not aligned with here.

903
1:02:48.057 --> 1:02:53.386
We color the root.
There's a chance when you do

904
1:02:53.386 --> 1:02:57.671
all of this that the root
becomes red.

905
1:02:57.671 --> 1:03:03
We always want the root to be
black.

906
1:03:03 --> 1:03:06.157
If it's red,
we set it to black at the very

907
1:03:06.157 --> 1:03:09.992
end of the algorithm.
This does not change the black

908
1:03:09.992 --> 1:03:13.375
height property.
Everything will still be fine

909
1:03:13.375 --> 1:03:17.586
because every path either goes
to the root or it doesn't,

910
1:03:17.586 --> 1:03:21.421
every x to leaf path.
So, changing the root from red

911
1:03:21.421 --> 1:03:25.105
to black is no problem.
It will increase the black

912
1:03:25.105 --> 1:03:28.714
heights of everyone,
but all the paths will still

913
1:03:28.714 --> 1:03:33
have the same value.
It will be one larger.

914
1:03:33 --> 1:03:37.224
So, let's look at the three
cases.

915
1:03:37.224 --> 1:03:41.704
And, I'm going to use some
notation.

916
1:03:41.704 --> 1:03:48.615
Remember, we had triangles in
order to denote arbitrary

917
1:03:48.615 --> 1:03:52.967
subtrees when we define a
rotation.

918
1:03:52.967 --> 1:04:00.519
I'm going to use triangle with
a dot on top to say that this

919
1:04:00.519 --> 1:04:08.448
subtree has a black root.
So, when I fill something

920
1:04:08.448 --> 1:04:15.344
white, it means black because
I'm on a black board.

921
1:04:15.344 --> 1:04:19.344
Sorry.
OK, and I also have the

922
1:04:19.344 --> 1:04:27.068
property that each of these
triangles have the same black

923
1:04:27.068 --> 1:04:31.569
height.
So, this will let me make sure

924
1:04:31.569 --> 1:04:35.424
that the black height property,
property four,

925
1:04:35.424 --> 1:04:39.45
is being observed.
So, let me just show you case

926
1:04:39.45 --> 1:04:42.105
one.
We always want to make sure

927
1:04:42.105 --> 1:04:46.988
property four is preserved
because it's really hard to get

928
1:04:46.988 --> 1:04:50.5
that back.
It's essentially the balance of

929
1:04:50.5 --> 1:04:53.84
the tree.
So, let's suppose we have some

930
1:04:53.84 --> 1:04:56.838
node, C, left child,
A, right child,

931
1:04:56.838 --> 1:05:00.778
B, and some subtrees hanging
off of those guys.

932
1:05:00.778 --> 1:05:05.318
And, all of those subtrees have
the same black height.

933
1:05:05.318 --> 1:05:09.258
So, in other words,
these things are all at the

934
1:05:09.258 --> 1:05:14.466
same level.
OK, this is not quite what I

935
1:05:14.466 --> 1:05:17.462
wanted, sorry.
So, I'm considering,

936
1:05:17.462 --> 1:05:21.162
this is node x.
x is red, and its parent is

937
1:05:21.162 --> 1:05:23.718
red.
Therefore, we need to fix

938
1:05:23.718 --> 1:05:26.361
something.
We look at the node,

939
1:05:26.361 --> 1:05:29.885
y, which is over here.
And, I'll call it,

940
1:05:29.885 --> 1:05:33.435
the key is D.
The node is called y.

941
1:05:33.435 --> 1:05:37.74
OK, it has subtrees hanging off
as well, all with the same black

942
1:05:37.74 --> 1:05:39.722
height.
So, that will be true.

943
1:05:39.722 --> 1:05:43.685
If all of these nodes are red,
then all of these nodes have

944
1:05:43.685 --> 1:05:46.145
the same black height.
And therefore,

945
1:05:46.145 --> 1:05:49.494
all of the child subtrees,
which have black roots,

946
1:05:49.494 --> 1:05:52.569
all had to have the same black
height as well.

947
1:05:52.569 --> 1:05:56.738
OK, so we're looking at a big
chunk of red children subtree of

948
1:05:56.738 --> 1:05:59.608
a black node,
looking at all the stuff that

949
1:05:59.608 --> 1:06:02.87
happens to be red.
In case one,

950
1:06:02.87 --> 1:06:07.153
why is red so it participates?
So, a way to think of this as

951
1:06:07.153 --> 1:06:10.346
if we converted into the
two-three-four-tree,

952
1:06:10.346 --> 1:06:13.104
or tried to,
we would merge all of this

953
1:06:13.104 --> 1:06:16.661
stuff into one node.
That's essentially what we're

954
1:06:16.661 --> 1:06:19.491
doing here.
This is not a two-three-four

955
1:06:19.491 --> 1:06:22.322
tree, though.
We now have five children,

956
1:06:22.322 --> 1:06:25.443
which is bad.
This is why we want to fix it.

957
1:06:25.443 --> 1:06:28.201
So, we're going to recolor in
case one.

958
1:06:28.201 --> 1:06:32.048
And, we're going to take C.
Instead of making C black,

959
1:06:32.048 --> 1:06:35.241
and A and D red,
we are going to make A and D

960
1:06:35.241 --> 1:06:39.173
black, and C red.
So, C is red.

961
1:06:39.173 --> 1:06:41.158
A is black.
D is black.

962
1:06:41.158 --> 1:06:45.22
And, the subtrees are the same.
B is the same.

963
1:06:45.22 --> 1:06:49.191
It's still red.
OK, now we need to check that

964
1:06:49.191 --> 1:06:54.245
we preserve property four,
that all of the paths have the

965
1:06:54.245 --> 1:06:59.48
same number of black nodes.
That follows because we know we

966
1:06:59.48 --> 1:07:04.733
didn't touch these subtrees.
They all have the same black

967
1:07:04.733 --> 1:07:06.963
height.
And, if you look at any path,

968
1:07:06.963 --> 1:07:10.802
like, all the paths from A are
going to have that black height.

969
1:07:10.802 --> 1:07:14.518
All the paths from C are going
to have that black height plus

970
1:07:14.518 --> 1:07:17.862
one because there's a black node
in all the left paths,

971
1:07:17.862 --> 1:07:20.834
and there is a black node in
all the right paths.

972
1:07:20.834 --> 1:07:23.064
So, all the black links are the
same.

973
1:07:23.064 --> 1:07:25.045
So, this preserves property
four.

974
1:07:25.045 --> 1:07:28.327
And, it fixes property three
locally because B used to

975
1:07:28.327 --> 1:07:31.884
violate A.
Now B does not violate

976
1:07:31.884 --> 1:07:34.882
anything.
C, now, might be violated.

977
1:07:34.882 --> 1:07:39.593
So, what we're going to do is
set x, our new value of x,

978
1:07:39.593 --> 1:07:42.162
will be C.
So, it used to be B.

979
1:07:42.162 --> 1:07:46.873
We move it up a couple levels.
Or, in the original tree,

980
1:07:46.873 --> 1:07:50.299
yeah, we also move it up a
couple levels.

981
1:07:50.299 --> 1:07:53.468
So, we're making progress up
the tree.

982
1:07:53.468 --> 1:07:57.494
And then we continue this loop.
That's case one:

983
1:07:57.494 --> 1:08:01.092
recolor, go up.
C may violate its parent in

984
1:08:01.092 --> 1:08:05.46
which case we have to recurse.
So, we are recursing,

985
1:08:05.46 --> 1:08:10
in some sense,
or continuing on C.

986
1:08:10 --> 1:08:13
So now, let's look at case two.

987
1:08:13 --> 1:08:39


988
1:08:39 --> 1:08:43.929
So, I'm still,
in some sense,

989
1:08:43.929 --> 1:08:49.915
defining this algorithm by
picture.

990
1:08:49.915 --> 1:08:56.957
This is some nice,
graphical, programming

991
1:08:56.957 --> 1:09:04
language.
So, let's draw case two.

992
1:09:04 --> 1:09:07.299
Yeah, I forgot to mention
something about case one.

993
1:09:07.299 --> 1:09:10.862
So, I drew some things here.
What do I actually know is

994
1:09:10.862 --> 1:09:13.238
true?
So, let's look at the algorithm

995
1:09:13.238 --> 1:09:16.868
in which I've now reversed.
But, we are assuming that we

996
1:09:16.868 --> 1:09:19.045
are in category A.
In other words,

997
1:09:19.045 --> 1:09:22.147
the parent is the left child of
the grandparent.

998
1:09:22.147 --> 1:09:25.182
So, A is the left child of C.
That much I knew.

999
1:09:25.182 --> 1:09:27.228
Therefore, y is the right
child.

1000
1:09:27.228 --> 1:09:32.713
D is the right child of C.
I didn't actually know whether

1001
1:09:32.713 --> 1:09:36.242
B was the right child or the
left child.

1002
1:09:36.242 --> 1:09:38.865
It didn't matter.
In case one,

1003
1:09:38.865 --> 1:09:42.665
it doesn't matter.
OK, so I should've said,

1004
1:09:42.665 --> 1:09:45.65
the children of A may be
reversed.

1005
1:09:45.65 --> 1:09:48.635
But it just said the same
picture.

1006
1:09:48.635 --> 1:09:53.158
OK, I thought of this because
in case two, we care.

1007
1:09:53.158 --> 1:09:56.325
So, case one:
we didn't really care.

1008
1:09:56.325 --> 1:09:58.586
In case two,
we say, well,

1009
1:09:58.586 --> 1:10:02.929
case two is up there,
is x the right child of the

1010
1:10:02.929 --> 1:10:08.864
parent, or the left child?
If it's the right child,

1011
1:10:08.864 --> 1:10:12.672
we are in case two.
So now, I can really know that

1012
1:10:12.672 --> 1:10:16.013
x here, which is B,
is the right child of A.

1013
1:10:16.013 --> 1:10:19.043
Before, I didn't know and I
didn't care.

1014
1:10:19.043 --> 1:10:21.841
Now, I'm assuming that it's
this way.

1015
1:10:21.841 --> 1:10:26.114
OK, y is still over here.
And now, now we know that y is

1016
1:10:26.114 --> 1:10:28.601
black.
So, y over here is a black

1017
1:10:28.601 --> 1:10:32.121
node.
So now, if I did the

1018
1:10:32.121 --> 1:10:36.045
contraction trick,
all of these nodes,

1019
1:10:36.045 --> 1:10:40.287
A, B, and C,
would conglomerate into one.

1020
1:10:40.287 --> 1:10:45.803
I only have four children.
That actually looks pretty

1021
1:10:45.803 --> 1:10:49.621
good.
y would not be involved because

1022
1:10:49.621 --> 1:10:52.59
it's black.
So, in this case,

1023
1:10:52.59 --> 1:10:58
we are going to do a left
rotation on A.

1024
1:10:58 --> 1:11:00.806
So, we take the edge,
we turn at 90°.

1025
1:11:00.806 --> 1:11:04.703
What we get is A on the left,
B on the right still.

1026
1:11:04.703 --> 1:11:09.146
It should preserve the in order
traversal, C up top still.

1027
1:11:09.146 --> 1:11:12.576
We have the y subtree hanging
off, as before.

1028
1:11:12.576 --> 1:11:16.708
We have one of the other three
subtrees hanging off B,

1029
1:11:16.708 --> 1:11:19.202
and the other two now hang off
A.

1030
1:11:19.202 --> 1:11:23.723
So, this is just a generic
rotation picture applied to this

1031
1:11:23.723 --> 1:11:25.594
edge.
OK, what that does,

1032
1:11:25.594 --> 1:11:29.881
is before we had a zigzag
between x and its grandparent.

1033
1:11:29.881 --> 1:11:36.875
Now, we have a zigzig.
We have a straight path between

1034
1:11:36.875 --> 1:11:40.25
x.
So, x is still down here.

1035
1:11:40.25 --> 1:11:47.625
I'm not changing x in this case
because after I do case two,

1036
1:11:47.625 --> 1:11:54.5
I immediately do case three.
So, this is what case three

1037
1:11:54.5 --> 1:12:00.125
will look like.
And now, I continue on to case

1038
1:12:00.125 --> 1:12:03.207
three.
So, finally,

1039
1:12:03.207 --> 1:12:08.137
here's case three.
And, this will finally complete

1040
1:12:08.137 --> 1:12:12.664
the insertion algorithm.
We have a black node,

1041
1:12:12.664 --> 1:12:15.783
C.
We have a red left child from

1042
1:12:15.783 --> 1:12:17.393
C.
We have a red,

1043
1:12:17.393 --> 1:12:23.128
left, grandchild which is x.
And then, we have these black

1044
1:12:23.128 --> 1:12:28.057
subtrees all of the same black
height hanging off,

1045
1:12:28.057 --> 1:12:35
OK, which is exactly what we
had at the end of case two.

1046
1:12:35 --> 1:12:37.401
So, that definitely connects
over.

1047
1:12:37.401 --> 1:12:40.458
And remember,
this is the only case left in

1048
1:12:40.458 --> 1:12:43.369
category A.
Category A, we assumed that B

1049
1:12:43.369 --> 1:12:46.644
was the parent of x,
was the left child of the

1050
1:12:46.644 --> 1:12:49.336
grandparent, B or C.
So, we know that.

1051
1:12:49.336 --> 1:12:52.757
We already did the case one,
y over here as red.

1052
1:12:52.757 --> 1:12:56.323
That was case one.
So, we are assuming y is black.

1053
1:12:56.323 --> 1:13:00.398
Now, we look at whether x was
the left child or the right

1054
1:13:00.398 --> 1:13:04.054
child.
If it was the right child,

1055
1:13:04.054 --> 1:13:08.637
we made it into the left child.
x actually did change here.

1056
1:13:08.637 --> 1:13:10.85
Before, x was B.
Now, x is A.

1057
1:13:10.85 --> 1:13:15.117
OK, and then case three,
finally, is when x is the left

1058
1:13:15.117 --> 1:13:19.858
child of the parent who is the
left child of the grandparent.

1059
1:13:19.858 --> 1:13:23.335
This is the last case we have
to worry about.

1060
1:13:23.335 --> 1:13:27.523
And, what we do is another
rotation just like the last

1061
1:13:27.523 --> 1:13:34.419
rotation we did in the example.
That was case three.

1062
1:13:34.419 --> 1:13:43.652
So, we're going to do a right
rotate in this case of C.

1063
1:13:43.652 --> 1:13:52.544
And, we are going to recolor.
OK, so, what do we get?

1064
1:13:52.544 --> 1:14:01.777
Well, B now becomes the root.
And, I'm going to make it

1065
1:14:01.777 --> 1:14:04.832
black.
OK, remember,

1066
1:14:04.832 --> 1:14:06.816
this is the root of the
subtree.

1067
1:14:06.816 --> 1:14:09.185
There is other stuff hanging
off here.

1068
1:14:09.185 --> 1:14:12.706
I really should have drawn
extra parents in all of these

1069
1:14:12.706 --> 1:14:14.947
pictures.
There was somewhere in the

1070
1:14:14.947 --> 1:14:17.379
middle of the tree.
I don't know where.

1071
1:14:17.379 --> 1:14:21.284
It could be a rightward branch;
it could be a leftward branch.

1072
1:14:21.284 --> 1:14:23.781
We don't know.
C becomes the child of B,

1073
1:14:23.781 --> 1:14:26.086
and I'm going to make it a red
child.

1074
1:14:26.086 --> 1:14:28.646
A becomes a child of B,
as it was before,

1075
1:14:28.646 --> 1:14:31.399
keep it red.
And, everything else just hangs

1076
1:14:31.399 --> 1:14:34.996
off.
So, there were four subtrees

1077
1:14:34.996 --> 1:14:38.418
all at the same black height.
And, in particular,

1078
1:14:38.418 --> 1:14:41.983
this last one had y,
but we don't particularly care

1079
1:14:41.983 --> 1:14:44.977
about y anymore.
Now, we are in really good

1080
1:14:44.977 --> 1:14:48.328
shape because we should have no
more violations.

1081
1:14:48.328 --> 1:14:51.964
Before, we had a violation
between x and its parent,

1082
1:14:51.964 --> 1:14:54.388
A and B.
Well, A and B still have a

1083
1:14:54.388 --> 1:14:57.311
parent child relation.
But B is now black.

1084
1:14:57.311 --> 1:15:00.234
And, B is black,
so we don't care what its

1085
1:15:00.234 --> 1:15:03.3
parent looks like.
It could be red or black.

1086
1:15:03.3 --> 1:15:06.151
Both are fine.
We are no longer violating

1087
1:15:06.151 --> 1:15:11
property three.
We should be done in this case.

1088
1:15:11 --> 1:15:13.626
Property three is now true.
If you want,

1089
1:15:13.626 --> 1:15:16.185
you can say,
well, x becomes this node.

1090
1:15:16.185 --> 1:15:19.35
And then, the loop says,
oh, x is no longer red.

1091
1:15:19.35 --> 1:15:22.447
Therefore, I'm done.
We also need to check that

1092
1:15:22.447 --> 1:15:25.545
property four is preserved
during this process.

1093
1:15:25.545 --> 1:15:29.181
Again, it's not hard because of
the two-three-four tree

1094
1:15:29.181 --> 1:15:32.464
transformation.
If I contract all the red

1095
1:15:32.464 --> 1:15:35.804
things into their parents,
everything else has a constant,

1096
1:15:35.804 --> 1:15:39.496
I mean, every path in that tree
has the same length because they

1097
1:15:39.496 --> 1:15:41.898
have the same black length.
And over here,

1098
1:15:41.898 --> 1:15:44.828
that will still be true.
It's a little bit trickier

1099
1:15:44.828 --> 1:15:47.64
here, because we are recoloring
at the same time.

1100
1:15:47.64 --> 1:15:50.863
But, if you look at a path that
comes through this tree,

1101
1:15:50.863 --> 1:15:54.437
it used to go through a black
node, C, and then maybe some red

1102
1:15:54.437 --> 1:15:57.425
stuff; I don't care.
And then, it went through these

1103
1:15:57.425 --> 1:16:01
trees, which all have the same
black height.

1104
1:16:01 --> 1:16:03.785
So they were all the same.
Now, you comment,

1105
1:16:03.785 --> 1:16:06.376
and you go through a black node
called B.

1106
1:16:06.376 --> 1:16:08.902
And then, you go through some
red nodes.

1107
1:16:08.902 --> 1:16:12.4
It doesn't really matter.
But all the trees that you go

1108
1:16:12.4 --> 1:16:15.251
through down here have the same
black height.

1109
1:16:15.251 --> 1:16:18.878
So, every path through this
tree will have the same black

1110
1:16:18.878 --> 1:16:21.663
length, OK, if it starts from
the same node.

1111
1:16:21.663 --> 1:16:25.032
So, we preserve property four.
We fix property three.

1112
1:16:25.032 --> 1:16:27.04
That is the insertion
algorithm.

1113
1:16:27.04 --> 1:16:29.696
It's pretty long.
This is something you'll

1114
1:16:29.696 --> 1:16:34.625
probably just have to memorize.
If you try a few examples,

1115
1:16:34.625 --> 1:16:37.562
it's not so hard.
We can see that all the things

1116
1:16:37.562 --> 1:16:40.25
we did in this example were the
three cases.

1117
1:16:40.25 --> 1:16:42.937
The first step,
which unfortunately I had to

1118
1:16:42.937 --> 1:16:45.375
erase for space,
all we did was recolor.

1119
1:16:45.375 --> 1:16:47.562
We recolored ten,
and eight, and 11.

1120
1:16:47.562 --> 1:16:50.687
That was a case one.
Ten was the grandparent of 15.

1121
1:16:50.687 --> 1:16:53.437
Then, we looked at ten.
Ten was the violator.

1122
1:16:53.437 --> 1:16:56.437
It was a zigzag case relative
to its grandparent.

1123
1:16:56.437 --> 1:16:59.875
So, we did a right rotation to
fix that, took this edge,

1124
1:16:59.875 --> 1:17:04
and turned it so that ten
became next to seven.

1125
1:17:04 --> 1:17:07.545
That's the picture on the top.
Then, 18, which is the new

1126
1:17:07.545 --> 1:17:10.268
violator, with its grandparent,
is a zigzig.

1127
1:17:10.268 --> 1:17:12.864
They are both going in the same
direction.

1128
1:17:12.864 --> 1:17:15.713
And, now, we do one more
rotation to fix that.

1129
1:17:15.713 --> 1:17:18.816
That's really the only thing
you have to remember.

1130
1:17:18.816 --> 1:17:21.032
Recolor your grandparent if you
can.

1131
1:17:21.032 --> 1:17:24.641
Otherwise, make it zigzig.
And then, do one last rotation.

1132
1:17:24.641 --> 1:17:26.604
And recolor.
And that will work.

1133
1:17:26.604 --> 1:17:30.403
I mean, if you remember that,
you will figure out the rest on

1134
1:17:30.403 --> 1:17:34.363
any particular example.
We rotate ten over.

1135
1:17:34.363 --> 1:17:37.665
That better be black,
because in this case it's

1136
1:17:37.665 --> 1:17:41.039
becoming the root.
But, we will make it black no

1137
1:17:41.039 --> 1:17:45.131
matter what happens because
there has to be one black node

1138
1:17:45.131 --> 1:17:47.5
there.
If we didn't recolor at the

1139
1:17:47.5 --> 1:17:50.443
same time, we would violate
property four.

1140
1:17:50.443 --> 1:17:54.606
Why don't I draw that just for,
OK, because I have a couple

1141
1:17:54.606 --> 1:17:57.405
minutes.
So, if we just did the rotation

1142
1:17:57.405 --> 1:18:00.061
here, so let's say,
not the following,

1143
1:18:00.061 --> 1:18:02.614
we take B.
B is red.

1144
1:18:02.614 --> 1:18:06.707
This will give some intuition
as to why the algorithm is this

1145
1:18:06.707 --> 1:18:09.709
way, and not some other way.
And, C is black.

1146
1:18:09.709 --> 1:18:13.461
That's what we would have
gotten if we just rotated this

1147
1:18:13.461 --> 1:18:16.327
tree, rotated B,
or rotated C to the right.

1148
1:18:16.327 --> 1:18:19.261
So, these subtrees hang off in
the same way.

1149
1:18:19.261 --> 1:18:23.013
Subtrees look great because
they all have the same black

1150
1:18:23.013 --> 1:18:24.378
height.
But, you see,

1151
1:18:24.378 --> 1:18:27.448
there's a problem.
If we look at all the paths

1152
1:18:27.448 --> 1:18:31.064
starting from B and going down
to a leaf, on the left,

1153
1:18:31.064 --> 1:18:34.884
the number of black nodes is
whatever the black height is

1154
1:18:34.884 --> 1:18:39.237
over here.
Label that: black height,

1155
1:18:39.237 --> 1:18:44.517
whereas all the paths on the
right will be that black height

1156
1:18:44.517 --> 1:18:49.797
plus one because C is black.
So now, we've violated property

1157
1:18:49.797 --> 1:18:52.75
four.
So, we don't do this in case

1158
1:18:52.75 --> 1:18:55.525
three.
After we do the rotation,

1159
1:18:55.525 --> 1:19:00
we also do a recoloring.
So, we get this.

1160
1:19:00 --> 1:19:02.652
In other words,
we are putting the black node

1161
1:19:02.652 --> 1:19:06.027
at the top because then every
path has to go through that

1162
1:19:06.027 --> 1:19:09.282
node, whereas over here,
some of the nodes went through

1163
1:19:09.282 --> 1:19:11.331
the C.
Some of them went through A.

1164
1:19:11.331 --> 1:19:13.983
So, this is bad.
Also, we would have violated

1165
1:19:13.983 --> 1:19:16.575
property three.
But, the really bad thing is

1166
1:19:16.575 --> 1:19:19.287
that we are violating property
four over here.

1167
1:19:19.287 --> 1:19:22
OK, let me sum up a little bit.

1168
1:19:22 --> 1:19:32


1169
1:19:32 --> 1:19:38.734
So, we've seen,
if we insert into a red black

1170
1:19:38.734 --> 1:19:44.397
tree, we can keep it a red black
tree.

1171
1:19:44.397 --> 1:19:53.734
So, RB insert adds x to the set
to the dynamic set that we are

1172
1:19:53.734 --> 1:20:02
trying to maintain,
and preserves red blackness.

1173
1:20:02 --> 1:20:06.036
So, it keeps the tree a red
black tree, which is good

1174
1:20:06.036 --> 1:20:09.762
because we know then it keeps
logarithmic height.

1175
1:20:09.762 --> 1:20:14.187
Therefore, all queries in red
black trees will keep taking

1176
1:20:14.187 --> 1:20:17.835
logarithmic time.
How long does red black insert

1177
1:20:17.835 --> 1:20:20.63
take?
We know we are aiming for log n

1178
1:20:20.63 --> 1:20:24.278
time preparation.
We are not going to prove that

1179
1:20:24.278 --> 1:20:27.616
formally, but it should be
pretty intuitive.

1180
1:20:27.616 --> 1:20:31.652
So, cases two and three,
sorry, pointing at the wrong

1181
1:20:31.652 --> 1:20:36
place, cases two and three are
terminal.

1182
1:20:36 --> 1:20:38.06
When we do case three,
we are done.

1183
1:20:38.06 --> 1:20:41.09
When we do case two,
we are about to do case three,

1184
1:20:41.09 --> 1:20:44.242
and then we are done.
OK, so the only thing we really

1185
1:20:44.242 --> 1:20:47.03
have to count is case one
because each of these

1186
1:20:47.03 --> 1:20:50.363
operations, they are recoloring,
rotation, they all take

1187
1:20:50.363 --> 1:20:52.484
constant time.
So, it's a matter of,

1188
1:20:52.484 --> 1:20:55.454
how many are there?
Case one does some recoloring,

1189
1:20:55.454 --> 1:21:00
doesn't change the tree at all,
and moves x up by two levels.

1190
1:21:00 --> 1:21:04.226
We know that the height of the
tree is, at most,

1191
1:21:04.226 --> 1:21:08.722
two log n plus one.
So, the number of case ones is,

1192
1:21:08.722 --> 1:21:13.577
at most, log n plus one.
OK, so the number of case ones

1193
1:21:13.577 --> 1:21:17.623
is, at most, log n.
So, those take log n time.

1194
1:21:17.623 --> 1:21:21.85
And then, the number of case
twos and threes is,

1195
1:21:21.85 --> 1:21:25.177
at most, one for one of these
columns.

1196
1:21:25.177 --> 1:21:28.234
Well, together,
twos and threes is,

1197
1:21:28.234 --> 1:21:31.111
at most, two.
OK, so, log n time,

1198
1:21:31.111 --> 1:21:34.778
cool.
The other thing that is

1199
1:21:34.778 --> 1:21:39.264
interesting about red black
insertion is that it only makes

1200
1:21:39.264 --> 1:21:42.898
order one rotations.
So, most of the changes are

1201
1:21:42.898 --> 1:21:46.146
recolorings.
Case one just does recoloring,

1202
1:21:46.146 --> 1:21:48.93
no rotations.
Case two maybe does one

1203
1:21:48.93 --> 1:21:52.024
rotation.
Case three does one rotation if

1204
1:21:52.024 --> 1:21:56.895
you happen to be in those cases.
So, the number of rotations is,

1205
1:21:56.895 --> 1:22:00.066
at most, two.
It's either one or two in an

1206
1:22:00.066 --> 1:22:03.666
insertion.
It's kind of nice because

1207
1:22:03.666 --> 1:22:07.733
rotating a tree is a bit more
annoying than recoloring a tree.

1208
1:22:07.733 --> 1:22:09.266
Why?
Because if you had,

1209
1:22:09.266 --> 1:22:12.266
say, a data structure,
you have a search tree,

1210
1:22:12.266 --> 1:22:16.133
presumably, people are using
the search tree for something.

1211
1:22:16.133 --> 1:22:18.133
They are, like,
making queries.

1212
1:22:18.133 --> 1:22:20.933
For example,
the search tree represents all

1213
1:22:20.933 --> 1:22:24.266
the documents matching the word
computer in Google.

1214
1:22:24.266 --> 1:22:28.199
You've got the Google T-shirt
on here, so let's use a Google

1215
1:22:28.199 --> 1:22:31.201
reference.
You have the search tree.

1216
1:22:31.201 --> 1:22:33.652
It stores all the things
containing the word Google.

1217
1:22:33.652 --> 1:22:36.44
You'd like to search may be for
the ones that were modified

1218
1:22:36.44 --> 1:22:38.843
after a certain date,
or whatever it is you want to

1219
1:22:38.843 --> 1:22:40.381
do.
So, you're doing some queries

1220
1:22:40.381 --> 1:22:42.207
on this tree.
And, people are pummeling

1221
1:22:42.207 --> 1:22:45.043
Google like crazy with queries.
They get a zillion a second.

1222
1:22:45.043 --> 1:22:47.638
Don't quote me on that.
The number may not be accurate.

1223
1:22:47.638 --> 1:22:49.849
It's a zillion.
But, people are making searches

1224
1:22:49.849 --> 1:22:51.627
all the time.
If you recolor the tree,

1225
1:22:51.627 --> 1:22:54.559
people can still make searches.
It's just a little bit you are

1226
1:22:54.559 --> 1:22:56.145
flipping.
I don't care in a search

1227
1:22:56.145 --> 1:22:58.885
whether a node is red or black
because I know it will have

1228
1:22:58.885 --> 1:23:02.608
logarithmic height.
So, you can come along and make

1229
1:23:02.608 --> 1:23:05.824
your occasional updates as your
crawler surfs the Web and finds

1230
1:23:05.824 --> 1:23:07.536
changes.
And, recoloring is great.

1231
1:23:07.536 --> 1:23:10.493
Rotation is a bit expensive
because you have to lock those

1232
1:23:10.493 --> 1:23:13.658
nodes, make sure no one touches
them for the duration that you

1233
1:23:13.658 --> 1:23:15.37
rotate them, and then unlock
them.

1234
1:23:15.37 --> 1:23:18.016
So, it's nice that the number
of rotations is small,

1235
1:23:18.016 --> 1:23:20.246
really small,
just two, whereas the time has

1236
1:23:20.246 --> 1:23:23.048
to be log n because we are
inserting into a sorted list

1237
1:23:23.048 --> 1:23:25.175
essentially.
So, there is an n log n lower

1238
1:23:25.175 --> 1:23:28.184
bound if we do n insertions.
OK, deletion and I'm not going

1239
1:23:28.184 --> 1:23:31.625
to cover here.
You should read it in the book.

1240
1:23:31.625 --> 1:23:34.455
It's a little bit more
complicated, but the same ideas.

1241
1:23:34.455 --> 1:23:37.338
It gets the same bounds:
log n time order one rotations.

1242
1:23:37.338 --> 1:23:39.435
So, check it out.
That's red black trees.

1243
1:23:39.435 --> 1:23:42.161
Now, you can maintain data in
log n time preparation:

1244
1:23:42.161 --> 1:23:43.996
cool.
We'll now see three ways to do

1245
1:23:43.996 --> 1:23:46
it.

